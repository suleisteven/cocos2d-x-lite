// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_game_2eproto__INCLUDED
#define PROTOBUF_game_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_game_2eproto();
void protobuf_AssignDesc_game_2eproto();
void protobuf_ShutdownFile_game_2eproto();

class MessageInfo;
class Basic;
class RegisterRequest;
class RegisterResponse;
class RenewMerchandise;
class SignReward;
class SkinChooseRequest;
class NickNameRandomRespone;
class MatchStartResponse;
class PLayerListResponse;
class FoodChangeResponse;
class FoodArea;
class RemainTimeResponse;
class RankListResponse;
class GameEndResponse;
class PlayerSkillRequest;
class PlayerSkillResponse;
class PlayerSkill;
class MapEntity;
class RankItem;
class CellVector;
class PlayerOperationRequest;
class UserInfo;
class Food;
class Cell;
class Player;
class SuperRenewInfo;
class RoomInfo;
class GameStateResponse;
class GameReadyRequest;
class UltimateSkillChooseRequest;
class UltimateSkillChooseResponse;
class PlayerRenewalRequest;
class PlayerRenewalResponse;
class Asylum;
class Prop;
class BackpackResponse;
class SkinMerchandise;
class SkillMerchandise;
class ShopMerchandiseResponse;
class BuyRequest;
class UserChangedResponse;
class UserInfoResponse;
class UltimateSkill;
class PrivilegeResponse;
class Privilege;
class AuthorizationRequest;
class AuthorizationResponse;
class PayOrderRequest;
class PayOrderResponse;
class OrderParam;
class PayResultRequest;
class PayResultResponse;
class GoldCoinListRequest;
class GoldCoinListResponse;
class GoldCoin;

// ===================================================================

class MessageInfo : public ::google::protobuf::Message {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageInfo& default_instance();

  void Swap(MessageInfo* other);

  // implements Message ----------------------------------------------

  MessageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 service = 1;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 1;
  inline ::google::protobuf::int32 service() const;
  inline void set_service(::google::protobuf::int32 value);

  // required int32 SN = 2;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSNFieldNumber = 2;
  inline ::google::protobuf::int32 sn() const;
  inline void set_sn(::google::protobuf::int32 value);

  // optional int32 code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional .Basic basic = 28;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 28;
  inline const ::Basic& basic() const;
  inline ::Basic* mutable_basic();
  inline ::Basic* release_basic();
  inline void set_allocated_basic(::Basic* basic);

  // optional .RegisterRequest registerRequest = 5;
  inline bool has_registerrequest() const;
  inline void clear_registerrequest();
  static const int kRegisterRequestFieldNumber = 5;
  inline const ::RegisterRequest& registerrequest() const;
  inline ::RegisterRequest* mutable_registerrequest();
  inline ::RegisterRequest* release_registerrequest();
  inline void set_allocated_registerrequest(::RegisterRequest* registerrequest);

  // optional .RegisterResponse registerResponse = 6;
  inline bool has_registerresponse() const;
  inline void clear_registerresponse();
  static const int kRegisterResponseFieldNumber = 6;
  inline const ::RegisterResponse& registerresponse() const;
  inline ::RegisterResponse* mutable_registerresponse();
  inline ::RegisterResponse* release_registerresponse();
  inline void set_allocated_registerresponse(::RegisterResponse* registerresponse);

  // optional .SkinChooseRequest skinChooseRequest = 7;
  inline bool has_skinchooserequest() const;
  inline void clear_skinchooserequest();
  static const int kSkinChooseRequestFieldNumber = 7;
  inline const ::SkinChooseRequest& skinchooserequest() const;
  inline ::SkinChooseRequest* mutable_skinchooserequest();
  inline ::SkinChooseRequest* release_skinchooserequest();
  inline void set_allocated_skinchooserequest(::SkinChooseRequest* skinchooserequest);

  // optional .NickNameRandomRespone NickNameRandomRespone = 8;
  inline bool has_nicknamerandomrespone() const;
  inline void clear_nicknamerandomrespone();
  static const int kNickNameRandomResponeFieldNumber = 8;
  inline const ::NickNameRandomRespone& nicknamerandomrespone() const;
  inline ::NickNameRandomRespone* mutable_nicknamerandomrespone();
  inline ::NickNameRandomRespone* release_nicknamerandomrespone();
  inline void set_allocated_nicknamerandomrespone(::NickNameRandomRespone* nicknamerandomrespone);

  // optional .MatchStartResponse matchStartResponse = 9;
  inline bool has_matchstartresponse() const;
  inline void clear_matchstartresponse();
  static const int kMatchStartResponseFieldNumber = 9;
  inline const ::MatchStartResponse& matchstartresponse() const;
  inline ::MatchStartResponse* mutable_matchstartresponse();
  inline ::MatchStartResponse* release_matchstartresponse();
  inline void set_allocated_matchstartresponse(::MatchStartResponse* matchstartresponse);

  // optional .PLayerListResponse pLayerListResponse = 10;
  inline bool has_playerlistresponse() const;
  inline void clear_playerlistresponse();
  static const int kPLayerListResponseFieldNumber = 10;
  inline const ::PLayerListResponse& playerlistresponse() const;
  inline ::PLayerListResponse* mutable_playerlistresponse();
  inline ::PLayerListResponse* release_playerlistresponse();
  inline void set_allocated_playerlistresponse(::PLayerListResponse* playerlistresponse);

  // optional .FoodChangeResponse foodChangeResponse = 11;
  inline bool has_foodchangeresponse() const;
  inline void clear_foodchangeresponse();
  static const int kFoodChangeResponseFieldNumber = 11;
  inline const ::FoodChangeResponse& foodchangeresponse() const;
  inline ::FoodChangeResponse* mutable_foodchangeresponse();
  inline ::FoodChangeResponse* release_foodchangeresponse();
  inline void set_allocated_foodchangeresponse(::FoodChangeResponse* foodchangeresponse);

  // optional .PlayerOperationRequest playerOperationRequest = 12;
  inline bool has_playeroperationrequest() const;
  inline void clear_playeroperationrequest();
  static const int kPlayerOperationRequestFieldNumber = 12;
  inline const ::PlayerOperationRequest& playeroperationrequest() const;
  inline ::PlayerOperationRequest* mutable_playeroperationrequest();
  inline ::PlayerOperationRequest* release_playeroperationrequest();
  inline void set_allocated_playeroperationrequest(::PlayerOperationRequest* playeroperationrequest);

  // optional .RemainTimeResponse remainTimeResponse = 13;
  inline bool has_remaintimeresponse() const;
  inline void clear_remaintimeresponse();
  static const int kRemainTimeResponseFieldNumber = 13;
  inline const ::RemainTimeResponse& remaintimeresponse() const;
  inline ::RemainTimeResponse* mutable_remaintimeresponse();
  inline ::RemainTimeResponse* release_remaintimeresponse();
  inline void set_allocated_remaintimeresponse(::RemainTimeResponse* remaintimeresponse);

  // optional .RankListResponse rankListResponse = 14;
  inline bool has_ranklistresponse() const;
  inline void clear_ranklistresponse();
  static const int kRankListResponseFieldNumber = 14;
  inline const ::RankListResponse& ranklistresponse() const;
  inline ::RankListResponse* mutable_ranklistresponse();
  inline ::RankListResponse* release_ranklistresponse();
  inline void set_allocated_ranklistresponse(::RankListResponse* ranklistresponse);

  // optional .GameEndResponse GameEndResponse = 15;
  inline bool has_gameendresponse() const;
  inline void clear_gameendresponse();
  static const int kGameEndResponseFieldNumber = 15;
  inline const ::GameEndResponse& gameendresponse() const;
  inline ::GameEndResponse* mutable_gameendresponse();
  inline ::GameEndResponse* release_gameendresponse();
  inline void set_allocated_gameendresponse(::GameEndResponse* gameendresponse);

  // optional .GameStateResponse gameStateResponse = 16;
  inline bool has_gamestateresponse() const;
  inline void clear_gamestateresponse();
  static const int kGameStateResponseFieldNumber = 16;
  inline const ::GameStateResponse& gamestateresponse() const;
  inline ::GameStateResponse* mutable_gamestateresponse();
  inline ::GameStateResponse* release_gamestateresponse();
  inline void set_allocated_gamestateresponse(::GameStateResponse* gamestateresponse);

  // optional .GameReadyRequest gameReadyRequest = 17;
  inline bool has_gamereadyrequest() const;
  inline void clear_gamereadyrequest();
  static const int kGameReadyRequestFieldNumber = 17;
  inline const ::GameReadyRequest& gamereadyrequest() const;
  inline ::GameReadyRequest* mutable_gamereadyrequest();
  inline ::GameReadyRequest* release_gamereadyrequest();
  inline void set_allocated_gamereadyrequest(::GameReadyRequest* gamereadyrequest);

  // optional .PlayerSkillRequest playerSkillRequest = 18;
  inline bool has_playerskillrequest() const;
  inline void clear_playerskillrequest();
  static const int kPlayerSkillRequestFieldNumber = 18;
  inline const ::PlayerSkillRequest& playerskillrequest() const;
  inline ::PlayerSkillRequest* mutable_playerskillrequest();
  inline ::PlayerSkillRequest* release_playerskillrequest();
  inline void set_allocated_playerskillrequest(::PlayerSkillRequest* playerskillrequest);

  // optional .PlayerSkillResponse playerSkillResponse = 19;
  inline bool has_playerskillresponse() const;
  inline void clear_playerskillresponse();
  static const int kPlayerSkillResponseFieldNumber = 19;
  inline const ::PlayerSkillResponse& playerskillresponse() const;
  inline ::PlayerSkillResponse* mutable_playerskillresponse();
  inline ::PlayerSkillResponse* release_playerskillresponse();
  inline void set_allocated_playerskillresponse(::PlayerSkillResponse* playerskillresponse);

  // optional .UltimateSkillChooseRequest UltimateSkillChooseRequest = 20;
  inline bool has_ultimateskillchooserequest() const;
  inline void clear_ultimateskillchooserequest();
  static const int kUltimateSkillChooseRequestFieldNumber = 20;
  inline const ::UltimateSkillChooseRequest& ultimateskillchooserequest() const;
  inline ::UltimateSkillChooseRequest* mutable_ultimateskillchooserequest();
  inline ::UltimateSkillChooseRequest* release_ultimateskillchooserequest();
  inline void set_allocated_ultimateskillchooserequest(::UltimateSkillChooseRequest* ultimateskillchooserequest);

  // optional .UltimateSkillChooseResponse UltimateSkillChooseResponse = 21;
  inline bool has_ultimateskillchooseresponse() const;
  inline void clear_ultimateskillchooseresponse();
  static const int kUltimateSkillChooseResponseFieldNumber = 21;
  inline const ::UltimateSkillChooseResponse& ultimateskillchooseresponse() const;
  inline ::UltimateSkillChooseResponse* mutable_ultimateskillchooseresponse();
  inline ::UltimateSkillChooseResponse* release_ultimateskillchooseresponse();
  inline void set_allocated_ultimateskillchooseresponse(::UltimateSkillChooseResponse* ultimateskillchooseresponse);

  // optional .PlayerRenewalRequest playerRenewalRequest = 22;
  inline bool has_playerrenewalrequest() const;
  inline void clear_playerrenewalrequest();
  static const int kPlayerRenewalRequestFieldNumber = 22;
  inline const ::PlayerRenewalRequest& playerrenewalrequest() const;
  inline ::PlayerRenewalRequest* mutable_playerrenewalrequest();
  inline ::PlayerRenewalRequest* release_playerrenewalrequest();
  inline void set_allocated_playerrenewalrequest(::PlayerRenewalRequest* playerrenewalrequest);

  // optional .PlayerRenewalResponse playerRenewalResponse = 23;
  inline bool has_playerrenewalresponse() const;
  inline void clear_playerrenewalresponse();
  static const int kPlayerRenewalResponseFieldNumber = 23;
  inline const ::PlayerRenewalResponse& playerrenewalresponse() const;
  inline ::PlayerRenewalResponse* mutable_playerrenewalresponse();
  inline ::PlayerRenewalResponse* release_playerrenewalresponse();
  inline void set_allocated_playerrenewalresponse(::PlayerRenewalResponse* playerrenewalresponse);

  // optional .BackpackResponse backpackResponse = 24;
  inline bool has_backpackresponse() const;
  inline void clear_backpackresponse();
  static const int kBackpackResponseFieldNumber = 24;
  inline const ::BackpackResponse& backpackresponse() const;
  inline ::BackpackResponse* mutable_backpackresponse();
  inline ::BackpackResponse* release_backpackresponse();
  inline void set_allocated_backpackresponse(::BackpackResponse* backpackresponse);

  // optional .ShopMerchandiseResponse shopMerchandiseResponse = 25;
  inline bool has_shopmerchandiseresponse() const;
  inline void clear_shopmerchandiseresponse();
  static const int kShopMerchandiseResponseFieldNumber = 25;
  inline const ::ShopMerchandiseResponse& shopmerchandiseresponse() const;
  inline ::ShopMerchandiseResponse* mutable_shopmerchandiseresponse();
  inline ::ShopMerchandiseResponse* release_shopmerchandiseresponse();
  inline void set_allocated_shopmerchandiseresponse(::ShopMerchandiseResponse* shopmerchandiseresponse);

  // optional .BuyRequest buyRequest = 26;
  inline bool has_buyrequest() const;
  inline void clear_buyrequest();
  static const int kBuyRequestFieldNumber = 26;
  inline const ::BuyRequest& buyrequest() const;
  inline ::BuyRequest* mutable_buyrequest();
  inline ::BuyRequest* release_buyrequest();
  inline void set_allocated_buyrequest(::BuyRequest* buyrequest);

  // optional .UserChangedResponse userChangedResponse = 27;
  inline bool has_userchangedresponse() const;
  inline void clear_userchangedresponse();
  static const int kUserChangedResponseFieldNumber = 27;
  inline const ::UserChangedResponse& userchangedresponse() const;
  inline ::UserChangedResponse* mutable_userchangedresponse();
  inline ::UserChangedResponse* release_userchangedresponse();
  inline void set_allocated_userchangedresponse(::UserChangedResponse* userchangedresponse);

  // optional .PrivilegeResponse privilegeResponse = 29;
  inline bool has_privilegeresponse() const;
  inline void clear_privilegeresponse();
  static const int kPrivilegeResponseFieldNumber = 29;
  inline const ::PrivilegeResponse& privilegeresponse() const;
  inline ::PrivilegeResponse* mutable_privilegeresponse();
  inline ::PrivilegeResponse* release_privilegeresponse();
  inline void set_allocated_privilegeresponse(::PrivilegeResponse* privilegeresponse);

  // optional .PayOrderRequest payOrderRequest = 30;
  inline bool has_payorderrequest() const;
  inline void clear_payorderrequest();
  static const int kPayOrderRequestFieldNumber = 30;
  inline const ::PayOrderRequest& payorderrequest() const;
  inline ::PayOrderRequest* mutable_payorderrequest();
  inline ::PayOrderRequest* release_payorderrequest();
  inline void set_allocated_payorderrequest(::PayOrderRequest* payorderrequest);

  // optional .PayOrderResponse payOrderResponse = 31;
  inline bool has_payorderresponse() const;
  inline void clear_payorderresponse();
  static const int kPayOrderResponseFieldNumber = 31;
  inline const ::PayOrderResponse& payorderresponse() const;
  inline ::PayOrderResponse* mutable_payorderresponse();
  inline ::PayOrderResponse* release_payorderresponse();
  inline void set_allocated_payorderresponse(::PayOrderResponse* payorderresponse);

  // optional .AuthorizationRequest authorizationRequest = 32;
  inline bool has_authorizationrequest() const;
  inline void clear_authorizationrequest();
  static const int kAuthorizationRequestFieldNumber = 32;
  inline const ::AuthorizationRequest& authorizationrequest() const;
  inline ::AuthorizationRequest* mutable_authorizationrequest();
  inline ::AuthorizationRequest* release_authorizationrequest();
  inline void set_allocated_authorizationrequest(::AuthorizationRequest* authorizationrequest);

  // optional .AuthorizationResponse authorizationResponse = 36;
  inline bool has_authorizationresponse() const;
  inline void clear_authorizationresponse();
  static const int kAuthorizationResponseFieldNumber = 36;
  inline const ::AuthorizationResponse& authorizationresponse() const;
  inline ::AuthorizationResponse* mutable_authorizationresponse();
  inline ::AuthorizationResponse* release_authorizationresponse();
  inline void set_allocated_authorizationresponse(::AuthorizationResponse* authorizationresponse);

  // optional .PayResultRequest payResultRequest = 33;
  inline bool has_payresultrequest() const;
  inline void clear_payresultrequest();
  static const int kPayResultRequestFieldNumber = 33;
  inline const ::PayResultRequest& payresultrequest() const;
  inline ::PayResultRequest* mutable_payresultrequest();
  inline ::PayResultRequest* release_payresultrequest();
  inline void set_allocated_payresultrequest(::PayResultRequest* payresultrequest);

  // optional .PayResultResponse PayResultResponse = 34;
  inline bool has_payresultresponse() const;
  inline void clear_payresultresponse();
  static const int kPayResultResponseFieldNumber = 34;
  inline const ::PayResultResponse& payresultresponse() const;
  inline ::PayResultResponse* mutable_payresultresponse();
  inline ::PayResultResponse* release_payresultresponse();
  inline void set_allocated_payresultresponse(::PayResultResponse* payresultresponse);

  // optional .UserInfoResponse userInfoResponse = 35;
  inline bool has_userinforesponse() const;
  inline void clear_userinforesponse();
  static const int kUserInfoResponseFieldNumber = 35;
  inline const ::UserInfoResponse& userinforesponse() const;
  inline ::UserInfoResponse* mutable_userinforesponse();
  inline ::UserInfoResponse* release_userinforesponse();
  inline void set_allocated_userinforesponse(::UserInfoResponse* userinforesponse);

  // optional .GoldCoinListRequest goldCoinListRequest = 37;
  inline bool has_goldcoinlistrequest() const;
  inline void clear_goldcoinlistrequest();
  static const int kGoldCoinListRequestFieldNumber = 37;
  inline const ::GoldCoinListRequest& goldcoinlistrequest() const;
  inline ::GoldCoinListRequest* mutable_goldcoinlistrequest();
  inline ::GoldCoinListRequest* release_goldcoinlistrequest();
  inline void set_allocated_goldcoinlistrequest(::GoldCoinListRequest* goldcoinlistrequest);

  // optional .GoldCoinListResponse goldCoinListResponse = 38;
  inline bool has_goldcoinlistresponse() const;
  inline void clear_goldcoinlistresponse();
  static const int kGoldCoinListResponseFieldNumber = 38;
  inline const ::GoldCoinListResponse& goldcoinlistresponse() const;
  inline ::GoldCoinListResponse* mutable_goldcoinlistresponse();
  inline ::GoldCoinListResponse* release_goldcoinlistresponse();
  inline void set_allocated_goldcoinlistresponse(::GoldCoinListResponse* goldcoinlistresponse);

  // @@protoc_insertion_point(class_scope:MessageInfo)
 private:
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_registerrequest();
  inline void clear_has_registerrequest();
  inline void set_has_registerresponse();
  inline void clear_has_registerresponse();
  inline void set_has_skinchooserequest();
  inline void clear_has_skinchooserequest();
  inline void set_has_nicknamerandomrespone();
  inline void clear_has_nicknamerandomrespone();
  inline void set_has_matchstartresponse();
  inline void clear_has_matchstartresponse();
  inline void set_has_playerlistresponse();
  inline void clear_has_playerlistresponse();
  inline void set_has_foodchangeresponse();
  inline void clear_has_foodchangeresponse();
  inline void set_has_playeroperationrequest();
  inline void clear_has_playeroperationrequest();
  inline void set_has_remaintimeresponse();
  inline void clear_has_remaintimeresponse();
  inline void set_has_ranklistresponse();
  inline void clear_has_ranklistresponse();
  inline void set_has_gameendresponse();
  inline void clear_has_gameendresponse();
  inline void set_has_gamestateresponse();
  inline void clear_has_gamestateresponse();
  inline void set_has_gamereadyrequest();
  inline void clear_has_gamereadyrequest();
  inline void set_has_playerskillrequest();
  inline void clear_has_playerskillrequest();
  inline void set_has_playerskillresponse();
  inline void clear_has_playerskillresponse();
  inline void set_has_ultimateskillchooserequest();
  inline void clear_has_ultimateskillchooserequest();
  inline void set_has_ultimateskillchooseresponse();
  inline void clear_has_ultimateskillchooseresponse();
  inline void set_has_playerrenewalrequest();
  inline void clear_has_playerrenewalrequest();
  inline void set_has_playerrenewalresponse();
  inline void clear_has_playerrenewalresponse();
  inline void set_has_backpackresponse();
  inline void clear_has_backpackresponse();
  inline void set_has_shopmerchandiseresponse();
  inline void clear_has_shopmerchandiseresponse();
  inline void set_has_buyrequest();
  inline void clear_has_buyrequest();
  inline void set_has_userchangedresponse();
  inline void clear_has_userchangedresponse();
  inline void set_has_privilegeresponse();
  inline void clear_has_privilegeresponse();
  inline void set_has_payorderrequest();
  inline void clear_has_payorderrequest();
  inline void set_has_payorderresponse();
  inline void clear_has_payorderresponse();
  inline void set_has_authorizationrequest();
  inline void clear_has_authorizationrequest();
  inline void set_has_authorizationresponse();
  inline void clear_has_authorizationresponse();
  inline void set_has_payresultrequest();
  inline void clear_has_payresultrequest();
  inline void set_has_payresultresponse();
  inline void clear_has_payresultresponse();
  inline void set_has_userinforesponse();
  inline void clear_has_userinforesponse();
  inline void set_has_goldcoinlistrequest();
  inline void clear_has_goldcoinlistrequest();
  inline void set_has_goldcoinlistresponse();
  inline void clear_has_goldcoinlistresponse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::google::protobuf::int32 service_;
  ::google::protobuf::int32 sn_;
  ::std::string* msg_;
  ::Basic* basic_;
  ::RegisterRequest* registerrequest_;
  ::RegisterResponse* registerresponse_;
  ::SkinChooseRequest* skinchooserequest_;
  ::NickNameRandomRespone* nicknamerandomrespone_;
  ::MatchStartResponse* matchstartresponse_;
  ::PLayerListResponse* playerlistresponse_;
  ::FoodChangeResponse* foodchangeresponse_;
  ::PlayerOperationRequest* playeroperationrequest_;
  ::RemainTimeResponse* remaintimeresponse_;
  ::RankListResponse* ranklistresponse_;
  ::GameEndResponse* gameendresponse_;
  ::GameStateResponse* gamestateresponse_;
  ::GameReadyRequest* gamereadyrequest_;
  ::PlayerSkillRequest* playerskillrequest_;
  ::PlayerSkillResponse* playerskillresponse_;
  ::UltimateSkillChooseRequest* ultimateskillchooserequest_;
  ::UltimateSkillChooseResponse* ultimateskillchooseresponse_;
  ::PlayerRenewalRequest* playerrenewalrequest_;
  ::PlayerRenewalResponse* playerrenewalresponse_;
  ::BackpackResponse* backpackresponse_;
  ::ShopMerchandiseResponse* shopmerchandiseresponse_;
  ::BuyRequest* buyrequest_;
  ::UserChangedResponse* userchangedresponse_;
  ::PrivilegeResponse* privilegeresponse_;
  ::PayOrderRequest* payorderrequest_;
  ::PayOrderResponse* payorderresponse_;
  ::AuthorizationRequest* authorizationrequest_;
  ::AuthorizationResponse* authorizationresponse_;
  ::PayResultRequest* payresultrequest_;
  ::PayResultResponse* payresultresponse_;
  ::UserInfoResponse* userinforesponse_;
  ::GoldCoinListRequest* goldcoinlistrequest_;
  ::GoldCoinListResponse* goldcoinlistresponse_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static MessageInfo* default_instance_;
};
// -------------------------------------------------------------------

class Basic : public ::google::protobuf::Message {
 public:
  Basic();
  virtual ~Basic();

  Basic(const Basic& from);

  inline Basic& operator=(const Basic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Basic& default_instance();

  void Swap(Basic* other);

  // implements Message ----------------------------------------------

  Basic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Basic& from);
  void MergeFrom(const Basic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:Basic)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* channel_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Basic* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  RegisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mac = 1;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 1;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string userPayId = 2;
  inline bool has_userpayid() const;
  inline void clear_userpayid();
  static const int kUserPayIdFieldNumber = 2;
  inline const ::std::string& userpayid() const;
  inline void set_userpayid(const ::std::string& value);
  inline void set_userpayid(const char* value);
  inline void set_userpayid(const char* value, size_t size);
  inline ::std::string* mutable_userpayid();
  inline ::std::string* release_userpayid();
  inline void set_allocated_userpayid(::std::string* userpayid);

  // optional string device = 3;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // @@protoc_insertion_point(class_scope:RegisterRequest)
 private:
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_userpayid();
  inline void clear_has_userpayid();
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mac_;
  ::std::string* userpayid_;
  ::std::string* device_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  void Swap(RegisterResponse* other);

  // implements Message ----------------------------------------------

  RegisterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // optional int32 propOverdue = 2;
  inline bool has_propoverdue() const;
  inline void clear_propoverdue();
  static const int kPropOverdueFieldNumber = 2;
  inline ::google::protobuf::int32 propoverdue() const;
  inline void set_propoverdue(::google::protobuf::int32 value);

  // repeated .SignReward signRewards = 3;
  inline int signrewards_size() const;
  inline void clear_signrewards();
  static const int kSignRewardsFieldNumber = 3;
  inline const ::SignReward& signrewards(int index) const;
  inline ::SignReward* mutable_signrewards(int index);
  inline ::SignReward* add_signrewards();
  inline const ::google::protobuf::RepeatedPtrField< ::SignReward >&
      signrewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::SignReward >*
      mutable_signrewards();

  // optional .RenewMerchandise renewMerchandise = 4;
  inline bool has_renewmerchandise() const;
  inline void clear_renewmerchandise();
  static const int kRenewMerchandiseFieldNumber = 4;
  inline const ::RenewMerchandise& renewmerchandise() const;
  inline ::RenewMerchandise* mutable_renewmerchandise();
  inline ::RenewMerchandise* release_renewmerchandise();
  inline void set_allocated_renewmerchandise(::RenewMerchandise* renewmerchandise);

  // @@protoc_insertion_point(class_scope:RegisterResponse)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_propoverdue();
  inline void clear_has_propoverdue();
  inline void set_has_renewmerchandise();
  inline void clear_has_renewmerchandise();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  ::google::protobuf::RepeatedPtrField< ::SignReward > signrewards_;
  ::RenewMerchandise* renewmerchandise_;
  ::google::protobuf::int32 propoverdue_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class RenewMerchandise : public ::google::protobuf::Message {
 public:
  RenewMerchandise();
  virtual ~RenewMerchandise();

  RenewMerchandise(const RenewMerchandise& from);

  inline RenewMerchandise& operator=(const RenewMerchandise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenewMerchandise& default_instance();

  void Swap(RenewMerchandise* other);

  // implements Message ----------------------------------------------

  RenewMerchandise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenewMerchandise& from);
  void MergeFrom(const RenewMerchandise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RenewMerchandise)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RenewMerchandise* default_instance_;
};
// -------------------------------------------------------------------

class SignReward : public ::google::protobuf::Message {
 public:
  SignReward();
  virtual ~SignReward();

  SignReward(const SignReward& from);

  inline SignReward& operator=(const SignReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignReward& default_instance();

  void Swap(SignReward* other);

  // implements Message ----------------------------------------------

  SignReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignReward& from);
  void MergeFrom(const SignReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // required int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SignReward)
 private:
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static SignReward* default_instance_;
};
// -------------------------------------------------------------------

class SkinChooseRequest : public ::google::protobuf::Message {
 public:
  SkinChooseRequest();
  virtual ~SkinChooseRequest();

  SkinChooseRequest(const SkinChooseRequest& from);

  inline SkinChooseRequest& operator=(const SkinChooseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkinChooseRequest& default_instance();

  void Swap(SkinChooseRequest* other);

  // implements Message ----------------------------------------------

  SkinChooseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkinChooseRequest& from);
  void MergeFrom(const SkinChooseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skin = 1;
  inline bool has_skin() const;
  inline void clear_skin();
  static const int kSkinFieldNumber = 1;
  inline ::google::protobuf::int32 skin() const;
  inline void set_skin(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SkinChooseRequest)
 private:
  inline void set_has_skin();
  inline void clear_has_skin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 skin_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static SkinChooseRequest* default_instance_;
};
// -------------------------------------------------------------------

class NickNameRandomRespone : public ::google::protobuf::Message {
 public:
  NickNameRandomRespone();
  virtual ~NickNameRandomRespone();

  NickNameRandomRespone(const NickNameRandomRespone& from);

  inline NickNameRandomRespone& operator=(const NickNameRandomRespone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NickNameRandomRespone& default_instance();

  void Swap(NickNameRandomRespone* other);

  // implements Message ----------------------------------------------

  NickNameRandomRespone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NickNameRandomRespone& from);
  void MergeFrom(const NickNameRandomRespone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:NickNameRandomRespone)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static NickNameRandomRespone* default_instance_;
};
// -------------------------------------------------------------------

class MatchStartResponse : public ::google::protobuf::Message {
 public:
  MatchStartResponse();
  virtual ~MatchStartResponse();

  MatchStartResponse(const MatchStartResponse& from);

  inline MatchStartResponse& operator=(const MatchStartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStartResponse& default_instance();

  void Swap(MatchStartResponse* other);

  // implements Message ----------------------------------------------

  MatchStartResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchStartResponse& from);
  void MergeFrom(const MatchStartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RoomInfo roomInfo = 1;
  inline bool has_roominfo() const;
  inline void clear_roominfo();
  static const int kRoomInfoFieldNumber = 1;
  inline const ::RoomInfo& roominfo() const;
  inline ::RoomInfo* mutable_roominfo();
  inline ::RoomInfo* release_roominfo();
  inline void set_allocated_roominfo(::RoomInfo* roominfo);

  // @@protoc_insertion_point(class_scope:MatchStartResponse)
 private:
  inline void set_has_roominfo();
  inline void clear_has_roominfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RoomInfo* roominfo_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static MatchStartResponse* default_instance_;
};
// -------------------------------------------------------------------

class PLayerListResponse : public ::google::protobuf::Message {
 public:
  PLayerListResponse();
  virtual ~PLayerListResponse();

  PLayerListResponse(const PLayerListResponse& from);

  inline PLayerListResponse& operator=(const PLayerListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PLayerListResponse& default_instance();

  void Swap(PLayerListResponse* other);

  // implements Message ----------------------------------------------

  PLayerListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PLayerListResponse& from);
  void MergeFrom(const PLayerListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Player allPlayers = 1;
  inline int allplayers_size() const;
  inline void clear_allplayers();
  static const int kAllPlayersFieldNumber = 1;
  inline const ::Player& allplayers(int index) const;
  inline ::Player* mutable_allplayers(int index);
  inline ::Player* add_allplayers();
  inline const ::google::protobuf::RepeatedPtrField< ::Player >&
      allplayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_allplayers();

  // repeated .Player removePlayers = 2;
  inline int removeplayers_size() const;
  inline void clear_removeplayers();
  static const int kRemovePlayersFieldNumber = 2;
  inline const ::Player& removeplayers(int index) const;
  inline ::Player* mutable_removeplayers(int index);
  inline ::Player* add_removeplayers();
  inline const ::google::protobuf::RepeatedPtrField< ::Player >&
      removeplayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_removeplayers();

  // repeated .Player newPlayers = 3;
  inline int newplayers_size() const;
  inline void clear_newplayers();
  static const int kNewPlayersFieldNumber = 3;
  inline const ::Player& newplayers(int index) const;
  inline ::Player* mutable_newplayers(int index);
  inline ::Player* add_newplayers();
  inline const ::google::protobuf::RepeatedPtrField< ::Player >&
      newplayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_newplayers();

  // repeated .Player changePlayers = 4;
  inline int changeplayers_size() const;
  inline void clear_changeplayers();
  static const int kChangePlayersFieldNumber = 4;
  inline const ::Player& changeplayers(int index) const;
  inline ::Player* mutable_changeplayers(int index);
  inline ::Player* add_changeplayers();
  inline const ::google::protobuf::RepeatedPtrField< ::Player >&
      changeplayers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_changeplayers();

  // @@protoc_insertion_point(class_scope:PLayerListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Player > allplayers_;
  ::google::protobuf::RepeatedPtrField< ::Player > removeplayers_;
  ::google::protobuf::RepeatedPtrField< ::Player > newplayers_;
  ::google::protobuf::RepeatedPtrField< ::Player > changeplayers_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PLayerListResponse* default_instance_;
};
// -------------------------------------------------------------------

class FoodChangeResponse : public ::google::protobuf::Message {
 public:
  FoodChangeResponse();
  virtual ~FoodChangeResponse();

  FoodChangeResponse(const FoodChangeResponse& from);

  inline FoodChangeResponse& operator=(const FoodChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FoodChangeResponse& default_instance();

  void Swap(FoodChangeResponse* other);

  // implements Message ----------------------------------------------

  FoodChangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FoodChangeResponse& from);
  void MergeFrom(const FoodChangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .FoodArea foodAreas = 2;
  inline int foodareas_size() const;
  inline void clear_foodareas();
  static const int kFoodAreasFieldNumber = 2;
  inline const ::FoodArea& foodareas(int index) const;
  inline ::FoodArea* mutable_foodareas(int index);
  inline ::FoodArea* add_foodareas();
  inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
      foodareas() const;
  inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
      mutable_foodareas();

  // @@protoc_insertion_point(class_scope:FoodChangeResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::FoodArea > foodareas_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static FoodChangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class FoodArea : public ::google::protobuf::Message {
 public:
  FoodArea();
  virtual ~FoodArea();

  FoodArea(const FoodArea& from);

  inline FoodArea& operator=(const FoodArea& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FoodArea& default_instance();

  void Swap(FoodArea* other);

  // implements Message ----------------------------------------------

  FoodArea* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FoodArea& from);
  void MergeFrom(const FoodArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 areaId = 1;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 areaid() const;
  inline void set_areaid(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // repeated .Food foods = 6;
  inline int foods_size() const;
  inline void clear_foods();
  static const int kFoodsFieldNumber = 6;
  inline const ::Food& foods(int index) const;
  inline ::Food* mutable_foods(int index);
  inline ::Food* add_foods();
  inline const ::google::protobuf::RepeatedPtrField< ::Food >&
      foods() const;
  inline ::google::protobuf::RepeatedPtrField< ::Food >*
      mutable_foods();

  // @@protoc_insertion_point(class_scope:FoodArea)
 private:
  inline void set_has_areaid();
  inline void clear_has_areaid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 areaid_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::RepeatedPtrField< ::Food > foods_;
  ::google::protobuf::int32 height_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static FoodArea* default_instance_;
};
// -------------------------------------------------------------------

class RemainTimeResponse : public ::google::protobuf::Message {
 public:
  RemainTimeResponse();
  virtual ~RemainTimeResponse();

  RemainTimeResponse(const RemainTimeResponse& from);

  inline RemainTimeResponse& operator=(const RemainTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemainTimeResponse& default_instance();

  void Swap(RemainTimeResponse* other);

  // implements Message ----------------------------------------------

  RemainTimeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemainTimeResponse& from);
  void MergeFrom(const RemainTimeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 remain = 1;
  inline bool has_remain() const;
  inline void clear_remain();
  static const int kRemainFieldNumber = 1;
  inline ::google::protobuf::int32 remain() const;
  inline void set_remain(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RemainTimeResponse)
 private:
  inline void set_has_remain();
  inline void clear_has_remain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 remain_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RemainTimeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RankListResponse : public ::google::protobuf::Message {
 public:
  RankListResponse();
  virtual ~RankListResponse();

  RankListResponse(const RankListResponse& from);

  inline RankListResponse& operator=(const RankListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RankListResponse& default_instance();

  void Swap(RankListResponse* other);

  // implements Message ----------------------------------------------

  RankListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankListResponse& from);
  void MergeFrom(const RankListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RankItem rankItems = 1;
  inline int rankitems_size() const;
  inline void clear_rankitems();
  static const int kRankItemsFieldNumber = 1;
  inline const ::RankItem& rankitems(int index) const;
  inline ::RankItem* mutable_rankitems(int index);
  inline ::RankItem* add_rankitems();
  inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
      rankitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
      mutable_rankitems();

  // @@protoc_insertion_point(class_scope:RankListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RankItem > rankitems_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RankListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GameEndResponse : public ::google::protobuf::Message {
 public:
  GameEndResponse();
  virtual ~GameEndResponse();

  GameEndResponse(const GameEndResponse& from);

  inline GameEndResponse& operator=(const GameEndResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEndResponse& default_instance();

  void Swap(GameEndResponse* other);

  // implements Message ----------------------------------------------

  GameEndResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEndResponse& from);
  void MergeFrom(const GameEndResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RankItem rankItems = 1;
  inline int rankitems_size() const;
  inline void clear_rankitems();
  static const int kRankItemsFieldNumber = 1;
  inline const ::RankItem& rankitems(int index) const;
  inline ::RankItem* mutable_rankitems(int index);
  inline ::RankItem* add_rankitems();
  inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
      rankitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
      mutable_rankitems();

  // @@protoc_insertion_point(class_scope:GameEndResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RankItem > rankitems_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GameEndResponse* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSkillRequest : public ::google::protobuf::Message {
 public:
  PlayerSkillRequest();
  virtual ~PlayerSkillRequest();

  PlayerSkillRequest(const PlayerSkillRequest& from);

  inline PlayerSkillRequest& operator=(const PlayerSkillRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSkillRequest& default_instance();

  void Swap(PlayerSkillRequest* other);

  // implements Message ----------------------------------------------

  PlayerSkillRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSkillRequest& from);
  void MergeFrom(const PlayerSkillRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skill = 1;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 1;
  inline ::google::protobuf::int32 skill() const;
  inline void set_skill(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerSkillRequest)
 private:
  inline void set_has_skill();
  inline void clear_has_skill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 skill_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerSkillRequest* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSkillResponse : public ::google::protobuf::Message {
 public:
  PlayerSkillResponse();
  virtual ~PlayerSkillResponse();

  PlayerSkillResponse(const PlayerSkillResponse& from);

  inline PlayerSkillResponse& operator=(const PlayerSkillResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSkillResponse& default_instance();

  void Swap(PlayerSkillResponse* other);

  // implements Message ----------------------------------------------

  PlayerSkillResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSkillResponse& from);
  void MergeFrom(const PlayerSkillResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerSkill playerSkills = 1;
  inline int playerskills_size() const;
  inline void clear_playerskills();
  static const int kPlayerSkillsFieldNumber = 1;
  inline const ::PlayerSkill& playerskills(int index) const;
  inline ::PlayerSkill* mutable_playerskills(int index);
  inline ::PlayerSkill* add_playerskills();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerSkill >&
      playerskills() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerSkill >*
      mutable_playerskills();

  // @@protoc_insertion_point(class_scope:PlayerSkillResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PlayerSkill > playerskills_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerSkillResponse* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSkill : public ::google::protobuf::Message {
 public:
  PlayerSkill();
  virtual ~PlayerSkill();

  PlayerSkill(const PlayerSkill& from);

  inline PlayerSkill& operator=(const PlayerSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSkill& default_instance();

  void Swap(PlayerSkill* other);

  // implements Message ----------------------------------------------

  PlayerSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSkill& from);
  void MergeFrom(const PlayerSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 skill = 1;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 1;
  inline ::google::protobuf::int32 skill() const;
  inline void set_skill(::google::protobuf::int32 value);

  // optional .Player player = 2;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::Player& player() const;
  inline ::Player* mutable_player();
  inline ::Player* release_player();
  inline void set_allocated_player(::Player* player);

  // optional int32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // repeated .MapEntity map = 4;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 4;
  inline const ::MapEntity& map(int index) const;
  inline ::MapEntity* mutable_map(int index);
  inline ::MapEntity* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntity >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntity >*
      mutable_map();

  // optional int32 duration = 5;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 5;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerSkill)
 private:
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Player* player_;
  ::google::protobuf::int32 skill_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::RepeatedPtrField< ::MapEntity > map_;
  ::google::protobuf::int32 duration_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerSkill* default_instance_;
};
// -------------------------------------------------------------------

class MapEntity : public ::google::protobuf::Message {
 public:
  MapEntity();
  virtual ~MapEntity();

  MapEntity(const MapEntity& from);

  inline MapEntity& operator=(const MapEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntity& default_instance();

  void Swap(MapEntity* other);

  // implements Message ----------------------------------------------

  MapEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapEntity& from);
  void MergeFrom(const MapEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:MapEntity)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static MapEntity* default_instance_;
};
// -------------------------------------------------------------------

class RankItem : public ::google::protobuf::Message {
 public:
  RankItem();
  virtual ~RankItem();

  RankItem(const RankItem& from);

  inline RankItem& operator=(const RankItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RankItem& default_instance();

  void Swap(RankItem* other);

  // implements Message ----------------------------------------------

  RankItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankItem& from);
  void MergeFrom(const RankItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional .UserInfo userInfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // optional int32 weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional int32 reward = 4;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 4;
  inline ::google::protobuf::int32 reward() const;
  inline void set_reward(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RankItem)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 reward_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RankItem* default_instance_;
};
// -------------------------------------------------------------------

class CellVector : public ::google::protobuf::Message {
 public:
  CellVector();
  virtual ~CellVector();

  CellVector(const CellVector& from);

  inline CellVector& operator=(const CellVector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellVector& default_instance();

  void Swap(CellVector* other);

  // implements Message ----------------------------------------------

  CellVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellVector& from);
  void MergeFrom(const CellVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cellId = 1;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIdFieldNumber = 1;
  inline ::google::protobuf::int32 cellid() const;
  inline void set_cellid(::google::protobuf::int32 value);

  // optional int32 angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline ::google::protobuf::int32 angle() const;
  inline void set_angle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CellVector)
 private:
  inline void set_has_cellid();
  inline void clear_has_cellid();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 cellid_;
  ::google::protobuf::int32 angle_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static CellVector* default_instance_;
};
// -------------------------------------------------------------------

class PlayerOperationRequest : public ::google::protobuf::Message {
 public:
  PlayerOperationRequest();
  virtual ~PlayerOperationRequest();

  PlayerOperationRequest(const PlayerOperationRequest& from);

  inline PlayerOperationRequest& operator=(const PlayerOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerOperationRequest& default_instance();

  void Swap(PlayerOperationRequest* other);

  // implements Message ----------------------------------------------

  PlayerOperationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerOperationRequest& from);
  void MergeFrom(const PlayerOperationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CellVector cellVector = 1;
  inline int cellvector_size() const;
  inline void clear_cellvector();
  static const int kCellVectorFieldNumber = 1;
  inline const ::CellVector& cellvector(int index) const;
  inline ::CellVector* mutable_cellvector(int index);
  inline ::CellVector* add_cellvector();
  inline const ::google::protobuf::RepeatedPtrField< ::CellVector >&
      cellvector() const;
  inline ::google::protobuf::RepeatedPtrField< ::CellVector >*
      mutable_cellvector();

  // @@protoc_insertion_point(class_scope:PlayerOperationRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CellVector > cellvector_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerOperationRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 skin = 2;
  inline bool has_skin() const;
  inline void clear_skin();
  static const int kSkinFieldNumber = 2;
  inline ::google::protobuf::int32 skin() const;
  inline void set_skin(::google::protobuf::int32 value);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .UltimateSkill ultimateSkill = 5;
  inline bool has_ultimateskill() const;
  inline void clear_ultimateskill();
  static const int kUltimateSkillFieldNumber = 5;
  inline const ::UltimateSkill& ultimateskill() const;
  inline ::UltimateSkill* mutable_ultimateskill();
  inline ::UltimateSkill* release_ultimateskill();
  inline void set_allocated_ultimateskill(::UltimateSkill* ultimateskill);

  // optional int32 gold = 6;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 stamina = 7;
  inline bool has_stamina() const;
  inline void clear_stamina();
  static const int kStaminaFieldNumber = 7;
  inline ::google::protobuf::int32 stamina() const;
  inline void set_stamina(::google::protobuf::int32 value);

  // optional int32 maxStamina = 8;
  inline bool has_maxstamina() const;
  inline void clear_maxstamina();
  static const int kMaxStaminaFieldNumber = 8;
  inline ::google::protobuf::int32 maxstamina() const;
  inline void set_maxstamina(::google::protobuf::int32 value);

  // optional int32 countdown = 9;
  inline bool has_countdown() const;
  inline void clear_countdown();
  static const int kCountdownFieldNumber = 9;
  inline ::google::protobuf::int32 countdown() const;
  inline void set_countdown(::google::protobuf::int32 value);

  // optional int32 privilege = 10;
  inline bool has_privilege() const;
  inline void clear_privilege();
  static const int kPrivilegeFieldNumber = 10;
  inline ::google::protobuf::int32 privilege() const;
  inline void set_privilege(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_skin();
  inline void clear_has_skin();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_ultimateskill();
  inline void clear_has_ultimateskill();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_stamina();
  inline void clear_has_stamina();
  inline void set_has_maxstamina();
  inline void clear_has_maxstamina();
  inline void set_has_countdown();
  inline void clear_has_countdown();
  inline void set_has_privilege();
  inline void clear_has_privilege();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 skin_;
  ::std::string* nickname_;
  ::std::string* account_;
  ::UltimateSkill* ultimateskill_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 stamina_;
  ::google::protobuf::int32 maxstamina_;
  ::google::protobuf::int32 countdown_;
  ::google::protobuf::int32 privilege_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class Food : public ::google::protobuf::Message {
 public:
  Food();
  virtual ~Food();

  Food(const Food& from);

  inline Food& operator=(const Food& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Food& default_instance();

  void Swap(Food* other);

  // implements Message ----------------------------------------------

  Food* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Food& from);
  void MergeFrom(const Food& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 skin = 2;
  inline bool has_skin() const;
  inline void clear_skin();
  static const int kSkinFieldNumber = 2;
  inline ::google::protobuf::int32 skin() const;
  inline void set_skin(::google::protobuf::int32 value);

  // optional int32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Food)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_skin();
  inline void clear_has_skin();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 skin_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Food* default_instance_;
};
// -------------------------------------------------------------------

class Cell : public ::google::protobuf::Message {
 public:
  Cell();
  virtual ~Cell();

  Cell(const Cell& from);

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell& default_instance();

  void Swap(Cell* other);

  // implements Message ----------------------------------------------

  Cell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);

  // optional int32 speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 angle = 6;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 6;
  inline ::google::protobuf::int32 angle() const;
  inline void set_angle(::google::protobuf::int32 value);

  // optional int32 fromId = 7;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromIdFieldNumber = 7;
  inline ::google::protobuf::int32 fromid() const;
  inline void set_fromid(::google::protobuf::int32 value);

  // optional int32 mergeId = 8;
  inline bool has_mergeid() const;
  inline void clear_mergeid();
  static const int kMergeIdFieldNumber = 8;
  inline ::google::protobuf::int32 mergeid() const;
  inline void set_mergeid(::google::protobuf::int32 value);

  // optional int32 status = 9;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 9;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .FoodArea magnetFoods = 10;
  inline int magnetfoods_size() const;
  inline void clear_magnetfoods();
  static const int kMagnetFoodsFieldNumber = 10;
  inline const ::FoodArea& magnetfoods(int index) const;
  inline ::FoodArea* mutable_magnetfoods(int index);
  inline ::FoodArea* add_magnetfoods();
  inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
      magnetfoods() const;
  inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
      mutable_magnetfoods();

  // @@protoc_insertion_point(class_scope:Cell)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_mergeid();
  inline void clear_has_mergeid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 radius_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 angle_;
  ::google::protobuf::int32 fromid_;
  ::google::protobuf::int32 mergeid_;
  ::google::protobuf::RepeatedPtrField< ::FoodArea > magnetfoods_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Cell* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // optional int32 weight = 2;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // repeated .Cell cells = 3;
  inline int cells_size() const;
  inline void clear_cells();
  static const int kCellsFieldNumber = 3;
  inline const ::Cell& cells(int index) const;
  inline ::Cell* mutable_cells(int index);
  inline ::Cell* add_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::Cell >&
      cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cell >*
      mutable_cells();

  // optional int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 ultimateSkillProgress = 5;
  inline bool has_ultimateskillprogress() const;
  inline void clear_ultimateskillprogress();
  static const int kUltimateSkillProgressFieldNumber = 5;
  inline ::google::protobuf::int32 ultimateskillprogress() const;
  inline void set_ultimateskillprogress(::google::protobuf::int32 value);

  // optional .UserInfo beKilledUserInfo = 6;
  inline bool has_bekilleduserinfo() const;
  inline void clear_bekilleduserinfo();
  static const int kBeKilledUserInfoFieldNumber = 6;
  inline const ::UserInfo& bekilleduserinfo() const;
  inline ::UserInfo* mutable_bekilleduserinfo();
  inline ::UserInfo* release_bekilleduserinfo();
  inline void set_allocated_bekilleduserinfo(::UserInfo* bekilleduserinfo);

  // optional .SuperRenewInfo superRenewInfo = 7;
  inline bool has_superrenewinfo() const;
  inline void clear_superrenewinfo();
  static const int kSuperRenewInfoFieldNumber = 7;
  inline const ::SuperRenewInfo& superrenewinfo() const;
  inline ::SuperRenewInfo* mutable_superrenewinfo();
  inline ::SuperRenewInfo* release_superrenewinfo();
  inline void set_allocated_superrenewinfo(::SuperRenewInfo* superrenewinfo);

  // @@protoc_insertion_point(class_scope:Player)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_ultimateskillprogress();
  inline void clear_has_ultimateskillprogress();
  inline void set_has_bekilleduserinfo();
  inline void clear_has_bekilleduserinfo();
  inline void set_has_superrenewinfo();
  inline void clear_has_superrenewinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  ::google::protobuf::RepeatedPtrField< ::Cell > cells_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 status_;
  ::UserInfo* bekilleduserinfo_;
  ::SuperRenewInfo* superrenewinfo_;
  ::google::protobuf::int32 ultimateskillprogress_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class SuperRenewInfo : public ::google::protobuf::Message {
 public:
  SuperRenewInfo();
  virtual ~SuperRenewInfo();

  SuperRenewInfo(const SuperRenewInfo& from);

  inline SuperRenewInfo& operator=(const SuperRenewInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperRenewInfo& default_instance();

  void Swap(SuperRenewInfo* other);

  // implements Message ----------------------------------------------

  SuperRenewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuperRenewInfo& from);
  void MergeFrom(const SuperRenewInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 weight = 2;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional int32 percent = 3;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 3;
  inline ::google::protobuf::int32 percent() const;
  inline void set_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SuperRenewInfo)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_percent();
  inline void clear_has_percent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 percent_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static SuperRenewInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 remainTime = 3;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 3;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);

  // optional int32 foodRadius = 4;
  inline bool has_foodradius() const;
  inline void clear_foodradius();
  static const int kFoodRadiusFieldNumber = 4;
  inline ::google::protobuf::int32 foodradius() const;
  inline void set_foodradius(::google::protobuf::int32 value);

  // repeated .Player players = 5;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 5;
  inline const ::Player& players(int index) const;
  inline ::Player* mutable_players(int index);
  inline ::Player* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::Player >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_players();

  // repeated .FoodArea foodAreas = 6;
  inline int foodareas_size() const;
  inline void clear_foodareas();
  static const int kFoodAreasFieldNumber = 6;
  inline const ::FoodArea& foodareas(int index) const;
  inline ::FoodArea* mutable_foodareas(int index);
  inline ::FoodArea* add_foodareas();
  inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
      foodareas() const;
  inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
      mutable_foodareas();

  // repeated .RankItem rankItems = 7;
  inline int rankitems_size() const;
  inline void clear_rankitems();
  static const int kRankItemsFieldNumber = 7;
  inline const ::RankItem& rankitems(int index) const;
  inline ::RankItem* mutable_rankitems(int index);
  inline ::RankItem* add_rankitems();
  inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
      rankitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
      mutable_rankitems();

  // repeated .Asylum asylums = 8;
  inline int asylums_size() const;
  inline void clear_asylums();
  static const int kAsylumsFieldNumber = 8;
  inline const ::Asylum& asylums(int index) const;
  inline ::Asylum* mutable_asylums(int index);
  inline ::Asylum* add_asylums();
  inline const ::google::protobuf::RepeatedPtrField< ::Asylum >&
      asylums() const;
  inline ::google::protobuf::RepeatedPtrField< ::Asylum >*
      mutable_asylums();

  // @@protoc_insertion_point(class_scope:RoomInfo)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_foodradius();
  inline void clear_has_foodradius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 remaintime_;
  ::google::protobuf::int32 foodradius_;
  ::google::protobuf::RepeatedPtrField< ::Player > players_;
  ::google::protobuf::RepeatedPtrField< ::FoodArea > foodareas_;
  ::google::protobuf::RepeatedPtrField< ::RankItem > rankitems_;
  ::google::protobuf::RepeatedPtrField< ::Asylum > asylums_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameStateResponse : public ::google::protobuf::Message {
 public:
  GameStateResponse();
  virtual ~GameStateResponse();

  GameStateResponse(const GameStateResponse& from);

  inline GameStateResponse& operator=(const GameStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStateResponse& default_instance();

  void Swap(GameStateResponse* other);

  // implements Message ----------------------------------------------

  GameStateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStateResponse& from);
  void MergeFrom(const GameStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string roomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:GameStateResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomid_;
  ::google::protobuf::int32 state_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GameStateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GameReadyRequest : public ::google::protobuf::Message {
 public:
  GameReadyRequest();
  virtual ~GameReadyRequest();

  GameReadyRequest(const GameReadyRequest& from);

  inline GameReadyRequest& operator=(const GameReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReadyRequest& default_instance();

  void Swap(GameReadyRequest* other);

  // implements Message ----------------------------------------------

  GameReadyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameReadyRequest& from);
  void MergeFrom(const GameReadyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:GameReadyRequest)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* roomid_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GameReadyRequest* default_instance_;
};
// -------------------------------------------------------------------

class UltimateSkillChooseRequest : public ::google::protobuf::Message {
 public:
  UltimateSkillChooseRequest();
  virtual ~UltimateSkillChooseRequest();

  UltimateSkillChooseRequest(const UltimateSkillChooseRequest& from);

  inline UltimateSkillChooseRequest& operator=(const UltimateSkillChooseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UltimateSkillChooseRequest& default_instance();

  void Swap(UltimateSkillChooseRequest* other);

  // implements Message ----------------------------------------------

  UltimateSkillChooseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UltimateSkillChooseRequest& from);
  void MergeFrom(const UltimateSkillChooseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ultimateSkill = 1;
  inline bool has_ultimateskill() const;
  inline void clear_ultimateskill();
  static const int kUltimateSkillFieldNumber = 1;
  inline ::google::protobuf::int32 ultimateskill() const;
  inline void set_ultimateskill(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UltimateSkillChooseRequest)
 private:
  inline void set_has_ultimateskill();
  inline void clear_has_ultimateskill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ultimateskill_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UltimateSkillChooseRequest* default_instance_;
};
// -------------------------------------------------------------------

class UltimateSkillChooseResponse : public ::google::protobuf::Message {
 public:
  UltimateSkillChooseResponse();
  virtual ~UltimateSkillChooseResponse();

  UltimateSkillChooseResponse(const UltimateSkillChooseResponse& from);

  inline UltimateSkillChooseResponse& operator=(const UltimateSkillChooseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UltimateSkillChooseResponse& default_instance();

  void Swap(UltimateSkillChooseResponse* other);

  // implements Message ----------------------------------------------

  UltimateSkillChooseResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UltimateSkillChooseResponse& from);
  void MergeFrom(const UltimateSkillChooseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:UltimateSkillChooseResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UltimateSkillChooseResponse* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRenewalRequest : public ::google::protobuf::Message {
 public:
  PlayerRenewalRequest();
  virtual ~PlayerRenewalRequest();

  PlayerRenewalRequest(const PlayerRenewalRequest& from);

  inline PlayerRenewalRequest& operator=(const PlayerRenewalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRenewalRequest& default_instance();

  void Swap(PlayerRenewalRequest* other);

  // implements Message ----------------------------------------------

  PlayerRenewalRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRenewalRequest& from);
  void MergeFrom(const PlayerRenewalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerRenewalRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerRenewalRequest* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRenewalResponse : public ::google::protobuf::Message {
 public:
  PlayerRenewalResponse();
  virtual ~PlayerRenewalResponse();

  PlayerRenewalResponse(const PlayerRenewalResponse& from);

  inline PlayerRenewalResponse& operator=(const PlayerRenewalResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRenewalResponse& default_instance();

  void Swap(PlayerRenewalResponse* other);

  // implements Message ----------------------------------------------

  PlayerRenewalResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRenewalResponse& from);
  void MergeFrom(const PlayerRenewalResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PlayerRenewalResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PlayerRenewalResponse* default_instance_;
};
// -------------------------------------------------------------------

class Asylum : public ::google::protobuf::Message {
 public:
  Asylum();
  virtual ~Asylum();

  Asylum(const Asylum& from);

  inline Asylum& operator=(const Asylum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asylum& default_instance();

  void Swap(Asylum* other);

  // implements Message ----------------------------------------------

  Asylum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asylum& from);
  void MergeFrom(const Asylum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 skin = 2;
  inline bool has_skin() const;
  inline void clear_skin();
  static const int kSkinFieldNumber = 2;
  inline ::google::protobuf::int32 skin() const;
  inline void set_skin(::google::protobuf::int32 value);

  // optional float x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // optional float radius = 5;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 5;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:Asylum)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_skin();
  inline void clear_has_skin();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 skin_;
  float x_;
  float y_;
  float radius_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Asylum* default_instance_;
};
// -------------------------------------------------------------------

class Prop : public ::google::protobuf::Message {
 public:
  Prop();
  virtual ~Prop();

  Prop(const Prop& from);

  inline Prop& operator=(const Prop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Prop& default_instance();

  void Swap(Prop* other);

  // implements Message ----------------------------------------------

  Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prop& from);
  void MergeFrom(const Prop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 remainDay = 2;
  inline bool has_remainday() const;
  inline void clear_remainday();
  static const int kRemainDayFieldNumber = 2;
  inline ::google::protobuf::int32 remainday() const;
  inline void set_remainday(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_remainday();
  inline void clear_has_remainday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 remainday_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Prop* default_instance_;
};
// -------------------------------------------------------------------

class BackpackResponse : public ::google::protobuf::Message {
 public:
  BackpackResponse();
  virtual ~BackpackResponse();

  BackpackResponse(const BackpackResponse& from);

  inline BackpackResponse& operator=(const BackpackResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackpackResponse& default_instance();

  void Swap(BackpackResponse* other);

  // implements Message ----------------------------------------------

  BackpackResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackpackResponse& from);
  void MergeFrom(const BackpackResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Prop skins = 1;
  inline int skins_size() const;
  inline void clear_skins();
  static const int kSkinsFieldNumber = 1;
  inline const ::Prop& skins(int index) const;
  inline ::Prop* mutable_skins(int index);
  inline ::Prop* add_skins();
  inline const ::google::protobuf::RepeatedPtrField< ::Prop >&
      skins() const;
  inline ::google::protobuf::RepeatedPtrField< ::Prop >*
      mutable_skins();

  // repeated .Prop skills = 2;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 2;
  inline const ::Prop& skills(int index) const;
  inline ::Prop* mutable_skills(int index);
  inline ::Prop* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::Prop >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::Prop >*
      mutable_skills();

  // @@protoc_insertion_point(class_scope:BackpackResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Prop > skins_;
  ::google::protobuf::RepeatedPtrField< ::Prop > skills_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static BackpackResponse* default_instance_;
};
// -------------------------------------------------------------------

class SkinMerchandise : public ::google::protobuf::Message {
 public:
  SkinMerchandise();
  virtual ~SkinMerchandise();

  SkinMerchandise(const SkinMerchandise& from);

  inline SkinMerchandise& operator=(const SkinMerchandise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkinMerchandise& default_instance();

  void Swap(SkinMerchandise* other);

  // implements Message ----------------------------------------------

  SkinMerchandise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkinMerchandise& from);
  void MergeFrom(const SkinMerchandise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 propId = 3;
  inline bool has_propid() const;
  inline void clear_propid();
  static const int kPropIdFieldNumber = 3;
  inline ::google::protobuf::int32 propid() const;
  inline void set_propid(::google::protobuf::int32 value);

  // required int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // required int32 availableDays = 5;
  inline bool has_availabledays() const;
  inline void clear_availabledays();
  static const int kAvailableDaysFieldNumber = 5;
  inline ::google::protobuf::int32 availabledays() const;
  inline void set_availabledays(::google::protobuf::int32 value);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional int32 tag = 7;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 7;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional int32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SkinMerchandise)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_propid();
  inline void clear_has_propid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_availabledays();
  inline void clear_has_availabledays();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 propid_;
  ::google::protobuf::int32 price_;
  ::std::string* description_;
  ::google::protobuf::int32 availabledays_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static SkinMerchandise* default_instance_;
};
// -------------------------------------------------------------------

class SkillMerchandise : public ::google::protobuf::Message {
 public:
  SkillMerchandise();
  virtual ~SkillMerchandise();

  SkillMerchandise(const SkillMerchandise& from);

  inline SkillMerchandise& operator=(const SkillMerchandise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillMerchandise& default_instance();

  void Swap(SkillMerchandise* other);

  // implements Message ----------------------------------------------

  SkillMerchandise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillMerchandise& from);
  void MergeFrom(const SkillMerchandise& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 propId = 3;
  inline bool has_propid() const;
  inline void clear_propid();
  static const int kPropIdFieldNumber = 3;
  inline ::google::protobuf::int32 propid() const;
  inline void set_propid(::google::protobuf::int32 value);

  // required int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // required int32 availableDays = 5;
  inline bool has_availabledays() const;
  inline void clear_availabledays();
  static const int kAvailableDaysFieldNumber = 5;
  inline ::google::protobuf::int32 availabledays() const;
  inline void set_availabledays(::google::protobuf::int32 value);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional int32 foodId = 7;
  inline bool has_foodid() const;
  inline void clear_foodid();
  static const int kFoodIdFieldNumber = 7;
  inline ::google::protobuf::int32 foodid() const;
  inline void set_foodid(::google::protobuf::int32 value);

  // required int32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SkillMerchandise)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_propid();
  inline void clear_has_propid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_availabledays();
  inline void clear_has_availabledays();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_foodid();
  inline void clear_has_foodid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 propid_;
  ::google::protobuf::int32 price_;
  ::std::string* description_;
  ::google::protobuf::int32 availabledays_;
  ::google::protobuf::int32 foodid_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static SkillMerchandise* default_instance_;
};
// -------------------------------------------------------------------

class ShopMerchandiseResponse : public ::google::protobuf::Message {
 public:
  ShopMerchandiseResponse();
  virtual ~ShopMerchandiseResponse();

  ShopMerchandiseResponse(const ShopMerchandiseResponse& from);

  inline ShopMerchandiseResponse& operator=(const ShopMerchandiseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShopMerchandiseResponse& default_instance();

  void Swap(ShopMerchandiseResponse* other);

  // implements Message ----------------------------------------------

  ShopMerchandiseResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShopMerchandiseResponse& from);
  void MergeFrom(const ShopMerchandiseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SkinMerchandise skinMerchandises = 1;
  inline int skinmerchandises_size() const;
  inline void clear_skinmerchandises();
  static const int kSkinMerchandisesFieldNumber = 1;
  inline const ::SkinMerchandise& skinmerchandises(int index) const;
  inline ::SkinMerchandise* mutable_skinmerchandises(int index);
  inline ::SkinMerchandise* add_skinmerchandises();
  inline const ::google::protobuf::RepeatedPtrField< ::SkinMerchandise >&
      skinmerchandises() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkinMerchandise >*
      mutable_skinmerchandises();

  // repeated .SkillMerchandise skillMerchandises = 2;
  inline int skillmerchandises_size() const;
  inline void clear_skillmerchandises();
  static const int kSkillMerchandisesFieldNumber = 2;
  inline const ::SkillMerchandise& skillmerchandises(int index) const;
  inline ::SkillMerchandise* mutable_skillmerchandises(int index);
  inline ::SkillMerchandise* add_skillmerchandises();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillMerchandise >&
      skillmerchandises() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillMerchandise >*
      mutable_skillmerchandises();

  // @@protoc_insertion_point(class_scope:ShopMerchandiseResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SkinMerchandise > skinmerchandises_;
  ::google::protobuf::RepeatedPtrField< ::SkillMerchandise > skillmerchandises_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static ShopMerchandiseResponse* default_instance_;
};
// -------------------------------------------------------------------

class BuyRequest : public ::google::protobuf::Message {
 public:
  BuyRequest();
  virtual ~BuyRequest();

  BuyRequest(const BuyRequest& from);

  inline BuyRequest& operator=(const BuyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyRequest& default_instance();

  void Swap(BuyRequest* other);

  // implements Message ----------------------------------------------

  BuyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuyRequest& from);
  void MergeFrom(const BuyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:BuyRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static BuyRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserChangedResponse : public ::google::protobuf::Message {
 public:
  UserChangedResponse();
  virtual ~UserChangedResponse();

  UserChangedResponse(const UserChangedResponse& from);

  inline UserChangedResponse& operator=(const UserChangedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChangedResponse& default_instance();

  void Swap(UserChangedResponse* other);

  // implements Message ----------------------------------------------

  UserChangedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserChangedResponse& from);
  void MergeFrom(const UserChangedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:UserChangedResponse)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UserChangedResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoResponse : public ::google::protobuf::Message {
 public:
  UserInfoResponse();
  virtual ~UserInfoResponse();

  UserInfoResponse(const UserInfoResponse& from);

  inline UserInfoResponse& operator=(const UserInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoResponse& default_instance();

  void Swap(UserInfoResponse* other);

  // implements Message ----------------------------------------------

  UserInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoResponse& from);
  void MergeFrom(const UserInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:UserInfoResponse)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UserInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class UltimateSkill : public ::google::protobuf::Message {
 public:
  UltimateSkill();
  virtual ~UltimateSkill();

  UltimateSkill(const UltimateSkill& from);

  inline UltimateSkill& operator=(const UltimateSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UltimateSkill& default_instance();

  void Swap(UltimateSkill* other);

  // implements Message ----------------------------------------------

  UltimateSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UltimateSkill& from);
  void MergeFrom(const UltimateSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 foodId = 2;
  inline bool has_foodid() const;
  inline void clear_foodid();
  static const int kFoodIdFieldNumber = 2;
  inline ::google::protobuf::int32 foodid() const;
  inline void set_foodid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UltimateSkill)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_foodid();
  inline void clear_has_foodid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 foodid_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static UltimateSkill* default_instance_;
};
// -------------------------------------------------------------------

class PrivilegeResponse : public ::google::protobuf::Message {
 public:
  PrivilegeResponse();
  virtual ~PrivilegeResponse();

  PrivilegeResponse(const PrivilegeResponse& from);

  inline PrivilegeResponse& operator=(const PrivilegeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivilegeResponse& default_instance();

  void Swap(PrivilegeResponse* other);

  // implements Message ----------------------------------------------

  PrivilegeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivilegeResponse& from);
  void MergeFrom(const PrivilegeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 stamina = 2;
  inline bool has_stamina() const;
  inline void clear_stamina();
  static const int kStaminaFieldNumber = 2;
  inline ::google::protobuf::int32 stamina() const;
  inline void set_stamina(::google::protobuf::int32 value);

  // optional int32 countdown = 3;
  inline bool has_countdown() const;
  inline void clear_countdown();
  static const int kCountdownFieldNumber = 3;
  inline ::google::protobuf::int32 countdown() const;
  inline void set_countdown(::google::protobuf::int32 value);

  // repeated .Privilege privileges = 4;
  inline int privileges_size() const;
  inline void clear_privileges();
  static const int kPrivilegesFieldNumber = 4;
  inline const ::Privilege& privileges(int index) const;
  inline ::Privilege* mutable_privileges(int index);
  inline ::Privilege* add_privileges();
  inline const ::google::protobuf::RepeatedPtrField< ::Privilege >&
      privileges() const;
  inline ::google::protobuf::RepeatedPtrField< ::Privilege >*
      mutable_privileges();

  // @@protoc_insertion_point(class_scope:PrivilegeResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_stamina();
  inline void clear_has_stamina();
  inline void set_has_countdown();
  inline void clear_has_countdown();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 stamina_;
  ::google::protobuf::RepeatedPtrField< ::Privilege > privileges_;
  ::google::protobuf::int32 countdown_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PrivilegeResponse* default_instance_;
};
// -------------------------------------------------------------------

class Privilege : public ::google::protobuf::Message {
 public:
  Privilege();
  virtual ~Privilege();

  Privilege(const Privilege& from);

  inline Privilege& operator=(const Privilege& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Privilege& default_instance();

  void Swap(Privilege* other);

  // implements Message ----------------------------------------------

  Privilege* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Privilege& from);
  void MergeFrom(const Privilege& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 orgPrice = 4;
  inline bool has_orgprice() const;
  inline void clear_orgprice();
  static const int kOrgPriceFieldNumber = 4;
  inline ::google::protobuf::int32 orgprice() const;
  inline void set_orgprice(::google::protobuf::int32 value);

  // required int32 price = 5;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 5;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 gold = 6;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 icon = 7;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 7;
  inline ::google::protobuf::int32 icon() const;
  inline void set_icon(::google::protobuf::int32 value);

  // optional string poster = 8;
  inline bool has_poster() const;
  inline void clear_poster();
  static const int kPosterFieldNumber = 8;
  inline const ::std::string& poster() const;
  inline void set_poster(const ::std::string& value);
  inline void set_poster(const char* value);
  inline void set_poster(const char* value, size_t size);
  inline ::std::string* mutable_poster();
  inline ::std::string* release_poster();
  inline void set_allocated_poster(::std::string* poster);

  // @@protoc_insertion_point(class_scope:Privilege)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_orgprice();
  inline void clear_has_orgprice();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_poster();
  inline void clear_has_poster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 orgprice_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 gold_;
  ::std::string* poster_;
  ::google::protobuf::int32 icon_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static Privilege* default_instance_;
};
// -------------------------------------------------------------------

class AuthorizationRequest : public ::google::protobuf::Message {
 public:
  AuthorizationRequest();
  virtual ~AuthorizationRequest();

  AuthorizationRequest(const AuthorizationRequest& from);

  inline AuthorizationRequest& operator=(const AuthorizationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthorizationRequest& default_instance();

  void Swap(AuthorizationRequest* other);

  // implements Message ----------------------------------------------

  AuthorizationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthorizationRequest& from);
  void MergeFrom(const AuthorizationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userPayId = 1;
  inline bool has_userpayid() const;
  inline void clear_userpayid();
  static const int kUserPayIdFieldNumber = 1;
  inline const ::std::string& userpayid() const;
  inline void set_userpayid(const ::std::string& value);
  inline void set_userpayid(const char* value);
  inline void set_userpayid(const char* value, size_t size);
  inline ::std::string* mutable_userpayid();
  inline ::std::string* release_userpayid();
  inline void set_allocated_userpayid(::std::string* userpayid);

  // @@protoc_insertion_point(class_scope:AuthorizationRequest)
 private:
  inline void set_has_userpayid();
  inline void clear_has_userpayid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userpayid_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static AuthorizationRequest* default_instance_;
};
// -------------------------------------------------------------------

class AuthorizationResponse : public ::google::protobuf::Message {
 public:
  AuthorizationResponse();
  virtual ~AuthorizationResponse();

  AuthorizationResponse(const AuthorizationResponse& from);

  inline AuthorizationResponse& operator=(const AuthorizationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthorizationResponse& default_instance();

  void Swap(AuthorizationResponse* other);

  // implements Message ----------------------------------------------

  AuthorizationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthorizationResponse& from);
  void MergeFrom(const AuthorizationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:AuthorizationResponse)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::UserInfo* userinfo_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static AuthorizationResponse* default_instance_;
};
// -------------------------------------------------------------------

class PayOrderRequest : public ::google::protobuf::Message {
 public:
  PayOrderRequest();
  virtual ~PayOrderRequest();

  PayOrderRequest(const PayOrderRequest& from);

  inline PayOrderRequest& operator=(const PayOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOrderRequest& default_instance();

  void Swap(PayOrderRequest* other);

  // implements Message ----------------------------------------------

  PayOrderRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOrderRequest& from);
  void MergeFrom(const PayOrderRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string goodsId = 2;
  inline bool has_goodsid() const;
  inline void clear_goodsid();
  static const int kGoodsIdFieldNumber = 2;
  inline const ::std::string& goodsid() const;
  inline void set_goodsid(const ::std::string& value);
  inline void set_goodsid(const char* value);
  inline void set_goodsid(const char* value, size_t size);
  inline ::std::string* mutable_goodsid();
  inline ::std::string* release_goodsid();
  inline void set_allocated_goodsid(::std::string* goodsid);

  // @@protoc_insertion_point(class_scope:PayOrderRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_goodsid();
  inline void clear_has_goodsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* goodsid_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PayOrderRequest* default_instance_;
};
// -------------------------------------------------------------------

class PayOrderResponse : public ::google::protobuf::Message {
 public:
  PayOrderResponse();
  virtual ~PayOrderResponse();

  PayOrderResponse(const PayOrderResponse& from);

  inline PayOrderResponse& operator=(const PayOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayOrderResponse& default_instance();

  void Swap(PayOrderResponse* other);

  // implements Message ----------------------------------------------

  PayOrderResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayOrderResponse& from);
  void MergeFrom(const PayOrderResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // required int32 price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // required .OrderParam orderParam = 3;
  inline bool has_orderparam() const;
  inline void clear_orderparam();
  static const int kOrderParamFieldNumber = 3;
  inline const ::OrderParam& orderparam() const;
  inline ::OrderParam* mutable_orderparam();
  inline ::OrderParam* release_orderparam();
  inline void set_allocated_orderparam(::OrderParam* orderparam);

  // optional int32 continueType = 4;
  inline bool has_continuetype() const;
  inline void clear_continuetype();
  static const int kContinueTypeFieldNumber = 4;
  inline ::google::protobuf::int32 continuetype() const;
  inline void set_continuetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PayOrderResponse)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_orderparam();
  inline void clear_has_orderparam();
  inline void set_has_continuetype();
  inline void clear_has_continuetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* orderid_;
  ::OrderParam* orderparam_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 continuetype_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PayOrderResponse* default_instance_;
};
// -------------------------------------------------------------------

class OrderParam : public ::google::protobuf::Message {
 public:
  OrderParam();
  virtual ~OrderParam();

  OrderParam(const OrderParam& from);

  inline OrderParam& operator=(const OrderParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderParam& default_instance();

  void Swap(OrderParam* other);

  // implements Message ----------------------------------------------

  OrderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderParam& from);
  void MergeFrom(const OrderParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string unicomFeeId = 2;
  inline bool has_unicomfeeid() const;
  inline void clear_unicomfeeid();
  static const int kUnicomFeeIdFieldNumber = 2;
  inline const ::std::string& unicomfeeid() const;
  inline void set_unicomfeeid(const ::std::string& value);
  inline void set_unicomfeeid(const char* value);
  inline void set_unicomfeeid(const char* value, size_t size);
  inline ::std::string* mutable_unicomfeeid();
  inline ::std::string* release_unicomfeeid();
  inline void set_allocated_unicomfeeid(::std::string* unicomfeeid);

  // optional string unicomProductId = 3;
  inline bool has_unicomproductid() const;
  inline void clear_unicomproductid();
  static const int kUnicomProductIdFieldNumber = 3;
  inline const ::std::string& unicomproductid() const;
  inline void set_unicomproductid(const ::std::string& value);
  inline void set_unicomproductid(const char* value);
  inline void set_unicomproductid(const char* value, size_t size);
  inline ::std::string* mutable_unicomproductid();
  inline ::std::string* release_unicomproductid();
  inline void set_allocated_unicomproductid(::std::string* unicomproductid);

  // optional string aliFeeId = 4;
  inline bool has_alifeeid() const;
  inline void clear_alifeeid();
  static const int kAliFeeIdFieldNumber = 4;
  inline const ::std::string& alifeeid() const;
  inline void set_alifeeid(const ::std::string& value);
  inline void set_alifeeid(const char* value);
  inline void set_alifeeid(const char* value, size_t size);
  inline ::std::string* mutable_alifeeid();
  inline ::std::string* release_alifeeid();
  inline void set_allocated_alifeeid(::std::string* alifeeid);

  // optional string weixinFeeId = 5;
  inline bool has_weixinfeeid() const;
  inline void clear_weixinfeeid();
  static const int kWeixinFeeIdFieldNumber = 5;
  inline const ::std::string& weixinfeeid() const;
  inline void set_weixinfeeid(const ::std::string& value);
  inline void set_weixinfeeid(const char* value);
  inline void set_weixinfeeid(const char* value, size_t size);
  inline ::std::string* mutable_weixinfeeid();
  inline ::std::string* release_weixinfeeid();
  inline void set_allocated_weixinfeeid(::std::string* weixinfeeid);

  // optional bool notify = 6;
  inline bool has_notify() const;
  inline void clear_notify();
  static const int kNotifyFieldNumber = 6;
  inline bool notify() const;
  inline void set_notify(bool value);

  // @@protoc_insertion_point(class_scope:OrderParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unicomfeeid();
  inline void clear_has_unicomfeeid();
  inline void set_has_unicomproductid();
  inline void clear_has_unicomproductid();
  inline void set_has_alifeeid();
  inline void clear_has_alifeeid();
  inline void set_has_weixinfeeid();
  inline void clear_has_weixinfeeid();
  inline void set_has_notify();
  inline void clear_has_notify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* unicomfeeid_;
  ::std::string* unicomproductid_;
  ::std::string* alifeeid_;
  ::std::string* weixinfeeid_;
  bool notify_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static OrderParam* default_instance_;
};
// -------------------------------------------------------------------

class PayResultRequest : public ::google::protobuf::Message {
 public:
  PayResultRequest();
  virtual ~PayResultRequest();

  PayResultRequest(const PayResultRequest& from);

  inline PayResultRequest& operator=(const PayResultRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayResultRequest& default_instance();

  void Swap(PayResultRequest* other);

  // implements Message ----------------------------------------------

  PayResultRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayResultRequest& from);
  void MergeFrom(const PayResultRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string orderId = 2;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // required string orderStatus = 3;
  inline bool has_orderstatus() const;
  inline void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 3;
  inline const ::std::string& orderstatus() const;
  inline void set_orderstatus(const ::std::string& value);
  inline void set_orderstatus(const char* value);
  inline void set_orderstatus(const char* value, size_t size);
  inline ::std::string* mutable_orderstatus();
  inline ::std::string* release_orderstatus();
  inline void set_allocated_orderstatus(::std::string* orderstatus);

  // @@protoc_insertion_point(class_scope:PayResultRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_orderstatus();
  inline void clear_has_orderstatus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* orderid_;
  ::std::string* orderstatus_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PayResultRequest* default_instance_;
};
// -------------------------------------------------------------------

class PayResultResponse : public ::google::protobuf::Message {
 public:
  PayResultResponse();
  virtual ~PayResultResponse();

  PayResultResponse(const PayResultResponse& from);

  inline PayResultResponse& operator=(const PayResultResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayResultResponse& default_instance();

  void Swap(PayResultResponse* other);

  // implements Message ----------------------------------------------

  PayResultResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayResultResponse& from);
  void MergeFrom(const PayResultResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // required string orderStatus = 2;
  inline bool has_orderstatus() const;
  inline void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 2;
  inline const ::std::string& orderstatus() const;
  inline void set_orderstatus(const ::std::string& value);
  inline void set_orderstatus(const char* value);
  inline void set_orderstatus(const char* value, size_t size);
  inline ::std::string* mutable_orderstatus();
  inline ::std::string* release_orderstatus();
  inline void set_allocated_orderstatus(::std::string* orderstatus);

  // optional .UserInfo userInfo = 3;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 3;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:PayResultResponse)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_orderstatus();
  inline void clear_has_orderstatus();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* orderid_;
  ::std::string* orderstatus_;
  ::UserInfo* userinfo_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static PayResultResponse* default_instance_;
};
// -------------------------------------------------------------------

class GoldCoinListRequest : public ::google::protobuf::Message {
 public:
  GoldCoinListRequest();
  virtual ~GoldCoinListRequest();

  GoldCoinListRequest(const GoldCoinListRequest& from);

  inline GoldCoinListRequest& operator=(const GoldCoinListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoldCoinListRequest& default_instance();

  void Swap(GoldCoinListRequest* other);

  // implements Message ----------------------------------------------

  GoldCoinListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoldCoinListRequest& from);
  void MergeFrom(const GoldCoinListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // required int32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GoldCoinListRequest)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 limit_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GoldCoinListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GoldCoinListResponse : public ::google::protobuf::Message {
 public:
  GoldCoinListResponse();
  virtual ~GoldCoinListResponse();

  GoldCoinListResponse(const GoldCoinListResponse& from);

  inline GoldCoinListResponse& operator=(const GoldCoinListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoldCoinListResponse& default_instance();

  void Swap(GoldCoinListResponse* other);

  // implements Message ----------------------------------------------

  GoldCoinListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoldCoinListResponse& from);
  void MergeFrom(const GoldCoinListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GoldCoin goldCoin = 1;
  inline int goldcoin_size() const;
  inline void clear_goldcoin();
  static const int kGoldCoinFieldNumber = 1;
  inline const ::GoldCoin& goldcoin(int index) const;
  inline ::GoldCoin* mutable_goldcoin(int index);
  inline ::GoldCoin* add_goldcoin();
  inline const ::google::protobuf::RepeatedPtrField< ::GoldCoin >&
      goldcoin() const;
  inline ::google::protobuf::RepeatedPtrField< ::GoldCoin >*
      mutable_goldcoin();

  // @@protoc_insertion_point(class_scope:GoldCoinListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GoldCoin > goldcoin_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GoldCoinListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GoldCoin : public ::google::protobuf::Message {
 public:
  GoldCoin();
  virtual ~GoldCoin();

  GoldCoin(const GoldCoin& from);

  inline GoldCoin& operator=(const GoldCoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoldCoin& default_instance();

  void Swap(GoldCoin* other);

  // implements Message ----------------------------------------------

  GoldCoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoldCoin& from);
  void MergeFrom(const GoldCoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required bool canBuy = 2;
  inline bool has_canbuy() const;
  inline void clear_canbuy();
  static const int kCanBuyFieldNumber = 2;
  inline bool canbuy() const;
  inline void set_canbuy(bool value);

  // optional int32 gold = 3;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 3;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional string poster = 6;
  inline bool has_poster() const;
  inline void clear_poster();
  static const int kPosterFieldNumber = 6;
  inline const ::std::string& poster() const;
  inline void set_poster(const ::std::string& value);
  inline void set_poster(const char* value);
  inline void set_poster(const char* value, size_t size);
  inline ::std::string* mutable_poster();
  inline ::std::string* release_poster();
  inline void set_allocated_poster(::std::string* poster);

  // @@protoc_insertion_point(class_scope:GoldCoin)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_canbuy();
  inline void clear_has_canbuy();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_poster();
  inline void clear_has_poster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  bool canbuy_;
  ::google::protobuf::int32 gold_;
  ::std::string* poster_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_game_2eproto();
  friend void protobuf_AssignDesc_game_2eproto();
  friend void protobuf_ShutdownFile_game_2eproto();

  void InitAsDefaultInstance();
  static GoldCoin* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageInfo

// required int32 service = 1;
inline bool MessageInfo::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInfo::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInfo::clear_service() {
  service_ = 0;
  clear_has_service();
}
inline ::google::protobuf::int32 MessageInfo::service() const {
  // @@protoc_insertion_point(field_get:MessageInfo.service)
  return service_;
}
inline void MessageInfo::set_service(::google::protobuf::int32 value) {
  set_has_service();
  service_ = value;
  // @@protoc_insertion_point(field_set:MessageInfo.service)
}

// required int32 SN = 2;
inline bool MessageInfo::has_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageInfo::set_has_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageInfo::clear_has_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageInfo::clear_sn() {
  sn_ = 0;
  clear_has_sn();
}
inline ::google::protobuf::int32 MessageInfo::sn() const {
  // @@protoc_insertion_point(field_get:MessageInfo.SN)
  return sn_;
}
inline void MessageInfo::set_sn(::google::protobuf::int32 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:MessageInfo.SN)
}

// optional int32 code = 3;
inline bool MessageInfo::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageInfo::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 MessageInfo::code() const {
  // @@protoc_insertion_point(field_get:MessageInfo.code)
  return code_;
}
inline void MessageInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:MessageInfo.code)
}

// optional string msg = 4;
inline bool MessageInfo::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageInfo::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageInfo::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageInfo::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MessageInfo::msg() const {
  // @@protoc_insertion_point(field_get:MessageInfo.msg)
  return *msg_;
}
inline void MessageInfo::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:MessageInfo.msg)
}
inline void MessageInfo::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageInfo.msg)
}
inline void MessageInfo::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageInfo.msg)
}
inline ::std::string* MessageInfo::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageInfo.msg)
  return msg_;
}
inline ::std::string* MessageInfo::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageInfo::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.msg)
}

// optional .Basic basic = 28;
inline bool MessageInfo::has_basic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageInfo::set_has_basic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageInfo::clear_has_basic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageInfo::clear_basic() {
  if (basic_ != NULL) basic_->::Basic::Clear();
  clear_has_basic();
}
inline const ::Basic& MessageInfo::basic() const {
  // @@protoc_insertion_point(field_get:MessageInfo.basic)
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
}
inline ::Basic* MessageInfo::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::Basic;
  // @@protoc_insertion_point(field_mutable:MessageInfo.basic)
  return basic_;
}
inline ::Basic* MessageInfo::release_basic() {
  clear_has_basic();
  ::Basic* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_basic(::Basic* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.basic)
}

// optional .RegisterRequest registerRequest = 5;
inline bool MessageInfo::has_registerrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageInfo::set_has_registerrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageInfo::clear_has_registerrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageInfo::clear_registerrequest() {
  if (registerrequest_ != NULL) registerrequest_->::RegisterRequest::Clear();
  clear_has_registerrequest();
}
inline const ::RegisterRequest& MessageInfo::registerrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.registerRequest)
  return registerrequest_ != NULL ? *registerrequest_ : *default_instance_->registerrequest_;
}
inline ::RegisterRequest* MessageInfo::mutable_registerrequest() {
  set_has_registerrequest();
  if (registerrequest_ == NULL) registerrequest_ = new ::RegisterRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.registerRequest)
  return registerrequest_;
}
inline ::RegisterRequest* MessageInfo::release_registerrequest() {
  clear_has_registerrequest();
  ::RegisterRequest* temp = registerrequest_;
  registerrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_registerrequest(::RegisterRequest* registerrequest) {
  delete registerrequest_;
  registerrequest_ = registerrequest;
  if (registerrequest) {
    set_has_registerrequest();
  } else {
    clear_has_registerrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.registerRequest)
}

// optional .RegisterResponse registerResponse = 6;
inline bool MessageInfo::has_registerresponse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageInfo::set_has_registerresponse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageInfo::clear_has_registerresponse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageInfo::clear_registerresponse() {
  if (registerresponse_ != NULL) registerresponse_->::RegisterResponse::Clear();
  clear_has_registerresponse();
}
inline const ::RegisterResponse& MessageInfo::registerresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.registerResponse)
  return registerresponse_ != NULL ? *registerresponse_ : *default_instance_->registerresponse_;
}
inline ::RegisterResponse* MessageInfo::mutable_registerresponse() {
  set_has_registerresponse();
  if (registerresponse_ == NULL) registerresponse_ = new ::RegisterResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.registerResponse)
  return registerresponse_;
}
inline ::RegisterResponse* MessageInfo::release_registerresponse() {
  clear_has_registerresponse();
  ::RegisterResponse* temp = registerresponse_;
  registerresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_registerresponse(::RegisterResponse* registerresponse) {
  delete registerresponse_;
  registerresponse_ = registerresponse;
  if (registerresponse) {
    set_has_registerresponse();
  } else {
    clear_has_registerresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.registerResponse)
}

// optional .SkinChooseRequest skinChooseRequest = 7;
inline bool MessageInfo::has_skinchooserequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageInfo::set_has_skinchooserequest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageInfo::clear_has_skinchooserequest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageInfo::clear_skinchooserequest() {
  if (skinchooserequest_ != NULL) skinchooserequest_->::SkinChooseRequest::Clear();
  clear_has_skinchooserequest();
}
inline const ::SkinChooseRequest& MessageInfo::skinchooserequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.skinChooseRequest)
  return skinchooserequest_ != NULL ? *skinchooserequest_ : *default_instance_->skinchooserequest_;
}
inline ::SkinChooseRequest* MessageInfo::mutable_skinchooserequest() {
  set_has_skinchooserequest();
  if (skinchooserequest_ == NULL) skinchooserequest_ = new ::SkinChooseRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.skinChooseRequest)
  return skinchooserequest_;
}
inline ::SkinChooseRequest* MessageInfo::release_skinchooserequest() {
  clear_has_skinchooserequest();
  ::SkinChooseRequest* temp = skinchooserequest_;
  skinchooserequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_skinchooserequest(::SkinChooseRequest* skinchooserequest) {
  delete skinchooserequest_;
  skinchooserequest_ = skinchooserequest;
  if (skinchooserequest) {
    set_has_skinchooserequest();
  } else {
    clear_has_skinchooserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.skinChooseRequest)
}

// optional .NickNameRandomRespone NickNameRandomRespone = 8;
inline bool MessageInfo::has_nicknamerandomrespone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageInfo::set_has_nicknamerandomrespone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageInfo::clear_has_nicknamerandomrespone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageInfo::clear_nicknamerandomrespone() {
  if (nicknamerandomrespone_ != NULL) nicknamerandomrespone_->::NickNameRandomRespone::Clear();
  clear_has_nicknamerandomrespone();
}
inline const ::NickNameRandomRespone& MessageInfo::nicknamerandomrespone() const {
  // @@protoc_insertion_point(field_get:MessageInfo.NickNameRandomRespone)
  return nicknamerandomrespone_ != NULL ? *nicknamerandomrespone_ : *default_instance_->nicknamerandomrespone_;
}
inline ::NickNameRandomRespone* MessageInfo::mutable_nicknamerandomrespone() {
  set_has_nicknamerandomrespone();
  if (nicknamerandomrespone_ == NULL) nicknamerandomrespone_ = new ::NickNameRandomRespone;
  // @@protoc_insertion_point(field_mutable:MessageInfo.NickNameRandomRespone)
  return nicknamerandomrespone_;
}
inline ::NickNameRandomRespone* MessageInfo::release_nicknamerandomrespone() {
  clear_has_nicknamerandomrespone();
  ::NickNameRandomRespone* temp = nicknamerandomrespone_;
  nicknamerandomrespone_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_nicknamerandomrespone(::NickNameRandomRespone* nicknamerandomrespone) {
  delete nicknamerandomrespone_;
  nicknamerandomrespone_ = nicknamerandomrespone;
  if (nicknamerandomrespone) {
    set_has_nicknamerandomrespone();
  } else {
    clear_has_nicknamerandomrespone();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.NickNameRandomRespone)
}

// optional .MatchStartResponse matchStartResponse = 9;
inline bool MessageInfo::has_matchstartresponse() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageInfo::set_has_matchstartresponse() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageInfo::clear_has_matchstartresponse() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageInfo::clear_matchstartresponse() {
  if (matchstartresponse_ != NULL) matchstartresponse_->::MatchStartResponse::Clear();
  clear_has_matchstartresponse();
}
inline const ::MatchStartResponse& MessageInfo::matchstartresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.matchStartResponse)
  return matchstartresponse_ != NULL ? *matchstartresponse_ : *default_instance_->matchstartresponse_;
}
inline ::MatchStartResponse* MessageInfo::mutable_matchstartresponse() {
  set_has_matchstartresponse();
  if (matchstartresponse_ == NULL) matchstartresponse_ = new ::MatchStartResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.matchStartResponse)
  return matchstartresponse_;
}
inline ::MatchStartResponse* MessageInfo::release_matchstartresponse() {
  clear_has_matchstartresponse();
  ::MatchStartResponse* temp = matchstartresponse_;
  matchstartresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_matchstartresponse(::MatchStartResponse* matchstartresponse) {
  delete matchstartresponse_;
  matchstartresponse_ = matchstartresponse;
  if (matchstartresponse) {
    set_has_matchstartresponse();
  } else {
    clear_has_matchstartresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.matchStartResponse)
}

// optional .PLayerListResponse pLayerListResponse = 10;
inline bool MessageInfo::has_playerlistresponse() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MessageInfo::set_has_playerlistresponse() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MessageInfo::clear_has_playerlistresponse() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MessageInfo::clear_playerlistresponse() {
  if (playerlistresponse_ != NULL) playerlistresponse_->::PLayerListResponse::Clear();
  clear_has_playerlistresponse();
}
inline const ::PLayerListResponse& MessageInfo::playerlistresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.pLayerListResponse)
  return playerlistresponse_ != NULL ? *playerlistresponse_ : *default_instance_->playerlistresponse_;
}
inline ::PLayerListResponse* MessageInfo::mutable_playerlistresponse() {
  set_has_playerlistresponse();
  if (playerlistresponse_ == NULL) playerlistresponse_ = new ::PLayerListResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.pLayerListResponse)
  return playerlistresponse_;
}
inline ::PLayerListResponse* MessageInfo::release_playerlistresponse() {
  clear_has_playerlistresponse();
  ::PLayerListResponse* temp = playerlistresponse_;
  playerlistresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playerlistresponse(::PLayerListResponse* playerlistresponse) {
  delete playerlistresponse_;
  playerlistresponse_ = playerlistresponse;
  if (playerlistresponse) {
    set_has_playerlistresponse();
  } else {
    clear_has_playerlistresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.pLayerListResponse)
}

// optional .FoodChangeResponse foodChangeResponse = 11;
inline bool MessageInfo::has_foodchangeresponse() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MessageInfo::set_has_foodchangeresponse() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MessageInfo::clear_has_foodchangeresponse() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MessageInfo::clear_foodchangeresponse() {
  if (foodchangeresponse_ != NULL) foodchangeresponse_->::FoodChangeResponse::Clear();
  clear_has_foodchangeresponse();
}
inline const ::FoodChangeResponse& MessageInfo::foodchangeresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.foodChangeResponse)
  return foodchangeresponse_ != NULL ? *foodchangeresponse_ : *default_instance_->foodchangeresponse_;
}
inline ::FoodChangeResponse* MessageInfo::mutable_foodchangeresponse() {
  set_has_foodchangeresponse();
  if (foodchangeresponse_ == NULL) foodchangeresponse_ = new ::FoodChangeResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.foodChangeResponse)
  return foodchangeresponse_;
}
inline ::FoodChangeResponse* MessageInfo::release_foodchangeresponse() {
  clear_has_foodchangeresponse();
  ::FoodChangeResponse* temp = foodchangeresponse_;
  foodchangeresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_foodchangeresponse(::FoodChangeResponse* foodchangeresponse) {
  delete foodchangeresponse_;
  foodchangeresponse_ = foodchangeresponse;
  if (foodchangeresponse) {
    set_has_foodchangeresponse();
  } else {
    clear_has_foodchangeresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.foodChangeResponse)
}

// optional .PlayerOperationRequest playerOperationRequest = 12;
inline bool MessageInfo::has_playeroperationrequest() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessageInfo::set_has_playeroperationrequest() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessageInfo::clear_has_playeroperationrequest() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessageInfo::clear_playeroperationrequest() {
  if (playeroperationrequest_ != NULL) playeroperationrequest_->::PlayerOperationRequest::Clear();
  clear_has_playeroperationrequest();
}
inline const ::PlayerOperationRequest& MessageInfo::playeroperationrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.playerOperationRequest)
  return playeroperationrequest_ != NULL ? *playeroperationrequest_ : *default_instance_->playeroperationrequest_;
}
inline ::PlayerOperationRequest* MessageInfo::mutable_playeroperationrequest() {
  set_has_playeroperationrequest();
  if (playeroperationrequest_ == NULL) playeroperationrequest_ = new ::PlayerOperationRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.playerOperationRequest)
  return playeroperationrequest_;
}
inline ::PlayerOperationRequest* MessageInfo::release_playeroperationrequest() {
  clear_has_playeroperationrequest();
  ::PlayerOperationRequest* temp = playeroperationrequest_;
  playeroperationrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playeroperationrequest(::PlayerOperationRequest* playeroperationrequest) {
  delete playeroperationrequest_;
  playeroperationrequest_ = playeroperationrequest;
  if (playeroperationrequest) {
    set_has_playeroperationrequest();
  } else {
    clear_has_playeroperationrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.playerOperationRequest)
}

// optional .RemainTimeResponse remainTimeResponse = 13;
inline bool MessageInfo::has_remaintimeresponse() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MessageInfo::set_has_remaintimeresponse() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MessageInfo::clear_has_remaintimeresponse() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MessageInfo::clear_remaintimeresponse() {
  if (remaintimeresponse_ != NULL) remaintimeresponse_->::RemainTimeResponse::Clear();
  clear_has_remaintimeresponse();
}
inline const ::RemainTimeResponse& MessageInfo::remaintimeresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.remainTimeResponse)
  return remaintimeresponse_ != NULL ? *remaintimeresponse_ : *default_instance_->remaintimeresponse_;
}
inline ::RemainTimeResponse* MessageInfo::mutable_remaintimeresponse() {
  set_has_remaintimeresponse();
  if (remaintimeresponse_ == NULL) remaintimeresponse_ = new ::RemainTimeResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.remainTimeResponse)
  return remaintimeresponse_;
}
inline ::RemainTimeResponse* MessageInfo::release_remaintimeresponse() {
  clear_has_remaintimeresponse();
  ::RemainTimeResponse* temp = remaintimeresponse_;
  remaintimeresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_remaintimeresponse(::RemainTimeResponse* remaintimeresponse) {
  delete remaintimeresponse_;
  remaintimeresponse_ = remaintimeresponse;
  if (remaintimeresponse) {
    set_has_remaintimeresponse();
  } else {
    clear_has_remaintimeresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.remainTimeResponse)
}

// optional .RankListResponse rankListResponse = 14;
inline bool MessageInfo::has_ranklistresponse() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MessageInfo::set_has_ranklistresponse() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MessageInfo::clear_has_ranklistresponse() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MessageInfo::clear_ranklistresponse() {
  if (ranklistresponse_ != NULL) ranklistresponse_->::RankListResponse::Clear();
  clear_has_ranklistresponse();
}
inline const ::RankListResponse& MessageInfo::ranklistresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.rankListResponse)
  return ranklistresponse_ != NULL ? *ranklistresponse_ : *default_instance_->ranklistresponse_;
}
inline ::RankListResponse* MessageInfo::mutable_ranklistresponse() {
  set_has_ranklistresponse();
  if (ranklistresponse_ == NULL) ranklistresponse_ = new ::RankListResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.rankListResponse)
  return ranklistresponse_;
}
inline ::RankListResponse* MessageInfo::release_ranklistresponse() {
  clear_has_ranklistresponse();
  ::RankListResponse* temp = ranklistresponse_;
  ranklistresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_ranklistresponse(::RankListResponse* ranklistresponse) {
  delete ranklistresponse_;
  ranklistresponse_ = ranklistresponse;
  if (ranklistresponse) {
    set_has_ranklistresponse();
  } else {
    clear_has_ranklistresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.rankListResponse)
}

// optional .GameEndResponse GameEndResponse = 15;
inline bool MessageInfo::has_gameendresponse() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MessageInfo::set_has_gameendresponse() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MessageInfo::clear_has_gameendresponse() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MessageInfo::clear_gameendresponse() {
  if (gameendresponse_ != NULL) gameendresponse_->::GameEndResponse::Clear();
  clear_has_gameendresponse();
}
inline const ::GameEndResponse& MessageInfo::gameendresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.GameEndResponse)
  return gameendresponse_ != NULL ? *gameendresponse_ : *default_instance_->gameendresponse_;
}
inline ::GameEndResponse* MessageInfo::mutable_gameendresponse() {
  set_has_gameendresponse();
  if (gameendresponse_ == NULL) gameendresponse_ = new ::GameEndResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.GameEndResponse)
  return gameendresponse_;
}
inline ::GameEndResponse* MessageInfo::release_gameendresponse() {
  clear_has_gameendresponse();
  ::GameEndResponse* temp = gameendresponse_;
  gameendresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_gameendresponse(::GameEndResponse* gameendresponse) {
  delete gameendresponse_;
  gameendresponse_ = gameendresponse;
  if (gameendresponse) {
    set_has_gameendresponse();
  } else {
    clear_has_gameendresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.GameEndResponse)
}

// optional .GameStateResponse gameStateResponse = 16;
inline bool MessageInfo::has_gamestateresponse() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MessageInfo::set_has_gamestateresponse() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MessageInfo::clear_has_gamestateresponse() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MessageInfo::clear_gamestateresponse() {
  if (gamestateresponse_ != NULL) gamestateresponse_->::GameStateResponse::Clear();
  clear_has_gamestateresponse();
}
inline const ::GameStateResponse& MessageInfo::gamestateresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.gameStateResponse)
  return gamestateresponse_ != NULL ? *gamestateresponse_ : *default_instance_->gamestateresponse_;
}
inline ::GameStateResponse* MessageInfo::mutable_gamestateresponse() {
  set_has_gamestateresponse();
  if (gamestateresponse_ == NULL) gamestateresponse_ = new ::GameStateResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.gameStateResponse)
  return gamestateresponse_;
}
inline ::GameStateResponse* MessageInfo::release_gamestateresponse() {
  clear_has_gamestateresponse();
  ::GameStateResponse* temp = gamestateresponse_;
  gamestateresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_gamestateresponse(::GameStateResponse* gamestateresponse) {
  delete gamestateresponse_;
  gamestateresponse_ = gamestateresponse;
  if (gamestateresponse) {
    set_has_gamestateresponse();
  } else {
    clear_has_gamestateresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.gameStateResponse)
}

// optional .GameReadyRequest gameReadyRequest = 17;
inline bool MessageInfo::has_gamereadyrequest() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MessageInfo::set_has_gamereadyrequest() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MessageInfo::clear_has_gamereadyrequest() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MessageInfo::clear_gamereadyrequest() {
  if (gamereadyrequest_ != NULL) gamereadyrequest_->::GameReadyRequest::Clear();
  clear_has_gamereadyrequest();
}
inline const ::GameReadyRequest& MessageInfo::gamereadyrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.gameReadyRequest)
  return gamereadyrequest_ != NULL ? *gamereadyrequest_ : *default_instance_->gamereadyrequest_;
}
inline ::GameReadyRequest* MessageInfo::mutable_gamereadyrequest() {
  set_has_gamereadyrequest();
  if (gamereadyrequest_ == NULL) gamereadyrequest_ = new ::GameReadyRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.gameReadyRequest)
  return gamereadyrequest_;
}
inline ::GameReadyRequest* MessageInfo::release_gamereadyrequest() {
  clear_has_gamereadyrequest();
  ::GameReadyRequest* temp = gamereadyrequest_;
  gamereadyrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_gamereadyrequest(::GameReadyRequest* gamereadyrequest) {
  delete gamereadyrequest_;
  gamereadyrequest_ = gamereadyrequest;
  if (gamereadyrequest) {
    set_has_gamereadyrequest();
  } else {
    clear_has_gamereadyrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.gameReadyRequest)
}

// optional .PlayerSkillRequest playerSkillRequest = 18;
inline bool MessageInfo::has_playerskillrequest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MessageInfo::set_has_playerskillrequest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MessageInfo::clear_has_playerskillrequest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MessageInfo::clear_playerskillrequest() {
  if (playerskillrequest_ != NULL) playerskillrequest_->::PlayerSkillRequest::Clear();
  clear_has_playerskillrequest();
}
inline const ::PlayerSkillRequest& MessageInfo::playerskillrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.playerSkillRequest)
  return playerskillrequest_ != NULL ? *playerskillrequest_ : *default_instance_->playerskillrequest_;
}
inline ::PlayerSkillRequest* MessageInfo::mutable_playerskillrequest() {
  set_has_playerskillrequest();
  if (playerskillrequest_ == NULL) playerskillrequest_ = new ::PlayerSkillRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.playerSkillRequest)
  return playerskillrequest_;
}
inline ::PlayerSkillRequest* MessageInfo::release_playerskillrequest() {
  clear_has_playerskillrequest();
  ::PlayerSkillRequest* temp = playerskillrequest_;
  playerskillrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playerskillrequest(::PlayerSkillRequest* playerskillrequest) {
  delete playerskillrequest_;
  playerskillrequest_ = playerskillrequest;
  if (playerskillrequest) {
    set_has_playerskillrequest();
  } else {
    clear_has_playerskillrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.playerSkillRequest)
}

// optional .PlayerSkillResponse playerSkillResponse = 19;
inline bool MessageInfo::has_playerskillresponse() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MessageInfo::set_has_playerskillresponse() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MessageInfo::clear_has_playerskillresponse() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MessageInfo::clear_playerskillresponse() {
  if (playerskillresponse_ != NULL) playerskillresponse_->::PlayerSkillResponse::Clear();
  clear_has_playerskillresponse();
}
inline const ::PlayerSkillResponse& MessageInfo::playerskillresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.playerSkillResponse)
  return playerskillresponse_ != NULL ? *playerskillresponse_ : *default_instance_->playerskillresponse_;
}
inline ::PlayerSkillResponse* MessageInfo::mutable_playerskillresponse() {
  set_has_playerskillresponse();
  if (playerskillresponse_ == NULL) playerskillresponse_ = new ::PlayerSkillResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.playerSkillResponse)
  return playerskillresponse_;
}
inline ::PlayerSkillResponse* MessageInfo::release_playerskillresponse() {
  clear_has_playerskillresponse();
  ::PlayerSkillResponse* temp = playerskillresponse_;
  playerskillresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playerskillresponse(::PlayerSkillResponse* playerskillresponse) {
  delete playerskillresponse_;
  playerskillresponse_ = playerskillresponse;
  if (playerskillresponse) {
    set_has_playerskillresponse();
  } else {
    clear_has_playerskillresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.playerSkillResponse)
}

// optional .UltimateSkillChooseRequest UltimateSkillChooseRequest = 20;
inline bool MessageInfo::has_ultimateskillchooserequest() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MessageInfo::set_has_ultimateskillchooserequest() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MessageInfo::clear_has_ultimateskillchooserequest() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MessageInfo::clear_ultimateskillchooserequest() {
  if (ultimateskillchooserequest_ != NULL) ultimateskillchooserequest_->::UltimateSkillChooseRequest::Clear();
  clear_has_ultimateskillchooserequest();
}
inline const ::UltimateSkillChooseRequest& MessageInfo::ultimateskillchooserequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.UltimateSkillChooseRequest)
  return ultimateskillchooserequest_ != NULL ? *ultimateskillchooserequest_ : *default_instance_->ultimateskillchooserequest_;
}
inline ::UltimateSkillChooseRequest* MessageInfo::mutable_ultimateskillchooserequest() {
  set_has_ultimateskillchooserequest();
  if (ultimateskillchooserequest_ == NULL) ultimateskillchooserequest_ = new ::UltimateSkillChooseRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.UltimateSkillChooseRequest)
  return ultimateskillchooserequest_;
}
inline ::UltimateSkillChooseRequest* MessageInfo::release_ultimateskillchooserequest() {
  clear_has_ultimateskillchooserequest();
  ::UltimateSkillChooseRequest* temp = ultimateskillchooserequest_;
  ultimateskillchooserequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_ultimateskillchooserequest(::UltimateSkillChooseRequest* ultimateskillchooserequest) {
  delete ultimateskillchooserequest_;
  ultimateskillchooserequest_ = ultimateskillchooserequest;
  if (ultimateskillchooserequest) {
    set_has_ultimateskillchooserequest();
  } else {
    clear_has_ultimateskillchooserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.UltimateSkillChooseRequest)
}

// optional .UltimateSkillChooseResponse UltimateSkillChooseResponse = 21;
inline bool MessageInfo::has_ultimateskillchooseresponse() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MessageInfo::set_has_ultimateskillchooseresponse() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MessageInfo::clear_has_ultimateskillchooseresponse() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MessageInfo::clear_ultimateskillchooseresponse() {
  if (ultimateskillchooseresponse_ != NULL) ultimateskillchooseresponse_->::UltimateSkillChooseResponse::Clear();
  clear_has_ultimateskillchooseresponse();
}
inline const ::UltimateSkillChooseResponse& MessageInfo::ultimateskillchooseresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.UltimateSkillChooseResponse)
  return ultimateskillchooseresponse_ != NULL ? *ultimateskillchooseresponse_ : *default_instance_->ultimateskillchooseresponse_;
}
inline ::UltimateSkillChooseResponse* MessageInfo::mutable_ultimateskillchooseresponse() {
  set_has_ultimateskillchooseresponse();
  if (ultimateskillchooseresponse_ == NULL) ultimateskillchooseresponse_ = new ::UltimateSkillChooseResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.UltimateSkillChooseResponse)
  return ultimateskillchooseresponse_;
}
inline ::UltimateSkillChooseResponse* MessageInfo::release_ultimateskillchooseresponse() {
  clear_has_ultimateskillchooseresponse();
  ::UltimateSkillChooseResponse* temp = ultimateskillchooseresponse_;
  ultimateskillchooseresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_ultimateskillchooseresponse(::UltimateSkillChooseResponse* ultimateskillchooseresponse) {
  delete ultimateskillchooseresponse_;
  ultimateskillchooseresponse_ = ultimateskillchooseresponse;
  if (ultimateskillchooseresponse) {
    set_has_ultimateskillchooseresponse();
  } else {
    clear_has_ultimateskillchooseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.UltimateSkillChooseResponse)
}

// optional .PlayerRenewalRequest playerRenewalRequest = 22;
inline bool MessageInfo::has_playerrenewalrequest() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MessageInfo::set_has_playerrenewalrequest() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MessageInfo::clear_has_playerrenewalrequest() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MessageInfo::clear_playerrenewalrequest() {
  if (playerrenewalrequest_ != NULL) playerrenewalrequest_->::PlayerRenewalRequest::Clear();
  clear_has_playerrenewalrequest();
}
inline const ::PlayerRenewalRequest& MessageInfo::playerrenewalrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.playerRenewalRequest)
  return playerrenewalrequest_ != NULL ? *playerrenewalrequest_ : *default_instance_->playerrenewalrequest_;
}
inline ::PlayerRenewalRequest* MessageInfo::mutable_playerrenewalrequest() {
  set_has_playerrenewalrequest();
  if (playerrenewalrequest_ == NULL) playerrenewalrequest_ = new ::PlayerRenewalRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.playerRenewalRequest)
  return playerrenewalrequest_;
}
inline ::PlayerRenewalRequest* MessageInfo::release_playerrenewalrequest() {
  clear_has_playerrenewalrequest();
  ::PlayerRenewalRequest* temp = playerrenewalrequest_;
  playerrenewalrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playerrenewalrequest(::PlayerRenewalRequest* playerrenewalrequest) {
  delete playerrenewalrequest_;
  playerrenewalrequest_ = playerrenewalrequest;
  if (playerrenewalrequest) {
    set_has_playerrenewalrequest();
  } else {
    clear_has_playerrenewalrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.playerRenewalRequest)
}

// optional .PlayerRenewalResponse playerRenewalResponse = 23;
inline bool MessageInfo::has_playerrenewalresponse() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MessageInfo::set_has_playerrenewalresponse() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MessageInfo::clear_has_playerrenewalresponse() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MessageInfo::clear_playerrenewalresponse() {
  if (playerrenewalresponse_ != NULL) playerrenewalresponse_->::PlayerRenewalResponse::Clear();
  clear_has_playerrenewalresponse();
}
inline const ::PlayerRenewalResponse& MessageInfo::playerrenewalresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.playerRenewalResponse)
  return playerrenewalresponse_ != NULL ? *playerrenewalresponse_ : *default_instance_->playerrenewalresponse_;
}
inline ::PlayerRenewalResponse* MessageInfo::mutable_playerrenewalresponse() {
  set_has_playerrenewalresponse();
  if (playerrenewalresponse_ == NULL) playerrenewalresponse_ = new ::PlayerRenewalResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.playerRenewalResponse)
  return playerrenewalresponse_;
}
inline ::PlayerRenewalResponse* MessageInfo::release_playerrenewalresponse() {
  clear_has_playerrenewalresponse();
  ::PlayerRenewalResponse* temp = playerrenewalresponse_;
  playerrenewalresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_playerrenewalresponse(::PlayerRenewalResponse* playerrenewalresponse) {
  delete playerrenewalresponse_;
  playerrenewalresponse_ = playerrenewalresponse;
  if (playerrenewalresponse) {
    set_has_playerrenewalresponse();
  } else {
    clear_has_playerrenewalresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.playerRenewalResponse)
}

// optional .BackpackResponse backpackResponse = 24;
inline bool MessageInfo::has_backpackresponse() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MessageInfo::set_has_backpackresponse() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MessageInfo::clear_has_backpackresponse() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MessageInfo::clear_backpackresponse() {
  if (backpackresponse_ != NULL) backpackresponse_->::BackpackResponse::Clear();
  clear_has_backpackresponse();
}
inline const ::BackpackResponse& MessageInfo::backpackresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.backpackResponse)
  return backpackresponse_ != NULL ? *backpackresponse_ : *default_instance_->backpackresponse_;
}
inline ::BackpackResponse* MessageInfo::mutable_backpackresponse() {
  set_has_backpackresponse();
  if (backpackresponse_ == NULL) backpackresponse_ = new ::BackpackResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.backpackResponse)
  return backpackresponse_;
}
inline ::BackpackResponse* MessageInfo::release_backpackresponse() {
  clear_has_backpackresponse();
  ::BackpackResponse* temp = backpackresponse_;
  backpackresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_backpackresponse(::BackpackResponse* backpackresponse) {
  delete backpackresponse_;
  backpackresponse_ = backpackresponse;
  if (backpackresponse) {
    set_has_backpackresponse();
  } else {
    clear_has_backpackresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.backpackResponse)
}

// optional .ShopMerchandiseResponse shopMerchandiseResponse = 25;
inline bool MessageInfo::has_shopmerchandiseresponse() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MessageInfo::set_has_shopmerchandiseresponse() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MessageInfo::clear_has_shopmerchandiseresponse() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MessageInfo::clear_shopmerchandiseresponse() {
  if (shopmerchandiseresponse_ != NULL) shopmerchandiseresponse_->::ShopMerchandiseResponse::Clear();
  clear_has_shopmerchandiseresponse();
}
inline const ::ShopMerchandiseResponse& MessageInfo::shopmerchandiseresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.shopMerchandiseResponse)
  return shopmerchandiseresponse_ != NULL ? *shopmerchandiseresponse_ : *default_instance_->shopmerchandiseresponse_;
}
inline ::ShopMerchandiseResponse* MessageInfo::mutable_shopmerchandiseresponse() {
  set_has_shopmerchandiseresponse();
  if (shopmerchandiseresponse_ == NULL) shopmerchandiseresponse_ = new ::ShopMerchandiseResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.shopMerchandiseResponse)
  return shopmerchandiseresponse_;
}
inline ::ShopMerchandiseResponse* MessageInfo::release_shopmerchandiseresponse() {
  clear_has_shopmerchandiseresponse();
  ::ShopMerchandiseResponse* temp = shopmerchandiseresponse_;
  shopmerchandiseresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_shopmerchandiseresponse(::ShopMerchandiseResponse* shopmerchandiseresponse) {
  delete shopmerchandiseresponse_;
  shopmerchandiseresponse_ = shopmerchandiseresponse;
  if (shopmerchandiseresponse) {
    set_has_shopmerchandiseresponse();
  } else {
    clear_has_shopmerchandiseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.shopMerchandiseResponse)
}

// optional .BuyRequest buyRequest = 26;
inline bool MessageInfo::has_buyrequest() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MessageInfo::set_has_buyrequest() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MessageInfo::clear_has_buyrequest() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MessageInfo::clear_buyrequest() {
  if (buyrequest_ != NULL) buyrequest_->::BuyRequest::Clear();
  clear_has_buyrequest();
}
inline const ::BuyRequest& MessageInfo::buyrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.buyRequest)
  return buyrequest_ != NULL ? *buyrequest_ : *default_instance_->buyrequest_;
}
inline ::BuyRequest* MessageInfo::mutable_buyrequest() {
  set_has_buyrequest();
  if (buyrequest_ == NULL) buyrequest_ = new ::BuyRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.buyRequest)
  return buyrequest_;
}
inline ::BuyRequest* MessageInfo::release_buyrequest() {
  clear_has_buyrequest();
  ::BuyRequest* temp = buyrequest_;
  buyrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_buyrequest(::BuyRequest* buyrequest) {
  delete buyrequest_;
  buyrequest_ = buyrequest;
  if (buyrequest) {
    set_has_buyrequest();
  } else {
    clear_has_buyrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.buyRequest)
}

// optional .UserChangedResponse userChangedResponse = 27;
inline bool MessageInfo::has_userchangedresponse() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MessageInfo::set_has_userchangedresponse() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MessageInfo::clear_has_userchangedresponse() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MessageInfo::clear_userchangedresponse() {
  if (userchangedresponse_ != NULL) userchangedresponse_->::UserChangedResponse::Clear();
  clear_has_userchangedresponse();
}
inline const ::UserChangedResponse& MessageInfo::userchangedresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.userChangedResponse)
  return userchangedresponse_ != NULL ? *userchangedresponse_ : *default_instance_->userchangedresponse_;
}
inline ::UserChangedResponse* MessageInfo::mutable_userchangedresponse() {
  set_has_userchangedresponse();
  if (userchangedresponse_ == NULL) userchangedresponse_ = new ::UserChangedResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.userChangedResponse)
  return userchangedresponse_;
}
inline ::UserChangedResponse* MessageInfo::release_userchangedresponse() {
  clear_has_userchangedresponse();
  ::UserChangedResponse* temp = userchangedresponse_;
  userchangedresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_userchangedresponse(::UserChangedResponse* userchangedresponse) {
  delete userchangedresponse_;
  userchangedresponse_ = userchangedresponse;
  if (userchangedresponse) {
    set_has_userchangedresponse();
  } else {
    clear_has_userchangedresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.userChangedResponse)
}

// optional .PrivilegeResponse privilegeResponse = 29;
inline bool MessageInfo::has_privilegeresponse() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MessageInfo::set_has_privilegeresponse() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MessageInfo::clear_has_privilegeresponse() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MessageInfo::clear_privilegeresponse() {
  if (privilegeresponse_ != NULL) privilegeresponse_->::PrivilegeResponse::Clear();
  clear_has_privilegeresponse();
}
inline const ::PrivilegeResponse& MessageInfo::privilegeresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.privilegeResponse)
  return privilegeresponse_ != NULL ? *privilegeresponse_ : *default_instance_->privilegeresponse_;
}
inline ::PrivilegeResponse* MessageInfo::mutable_privilegeresponse() {
  set_has_privilegeresponse();
  if (privilegeresponse_ == NULL) privilegeresponse_ = new ::PrivilegeResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.privilegeResponse)
  return privilegeresponse_;
}
inline ::PrivilegeResponse* MessageInfo::release_privilegeresponse() {
  clear_has_privilegeresponse();
  ::PrivilegeResponse* temp = privilegeresponse_;
  privilegeresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_privilegeresponse(::PrivilegeResponse* privilegeresponse) {
  delete privilegeresponse_;
  privilegeresponse_ = privilegeresponse;
  if (privilegeresponse) {
    set_has_privilegeresponse();
  } else {
    clear_has_privilegeresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.privilegeResponse)
}

// optional .PayOrderRequest payOrderRequest = 30;
inline bool MessageInfo::has_payorderrequest() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MessageInfo::set_has_payorderrequest() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MessageInfo::clear_has_payorderrequest() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MessageInfo::clear_payorderrequest() {
  if (payorderrequest_ != NULL) payorderrequest_->::PayOrderRequest::Clear();
  clear_has_payorderrequest();
}
inline const ::PayOrderRequest& MessageInfo::payorderrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.payOrderRequest)
  return payorderrequest_ != NULL ? *payorderrequest_ : *default_instance_->payorderrequest_;
}
inline ::PayOrderRequest* MessageInfo::mutable_payorderrequest() {
  set_has_payorderrequest();
  if (payorderrequest_ == NULL) payorderrequest_ = new ::PayOrderRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.payOrderRequest)
  return payorderrequest_;
}
inline ::PayOrderRequest* MessageInfo::release_payorderrequest() {
  clear_has_payorderrequest();
  ::PayOrderRequest* temp = payorderrequest_;
  payorderrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_payorderrequest(::PayOrderRequest* payorderrequest) {
  delete payorderrequest_;
  payorderrequest_ = payorderrequest;
  if (payorderrequest) {
    set_has_payorderrequest();
  } else {
    clear_has_payorderrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.payOrderRequest)
}

// optional .PayOrderResponse payOrderResponse = 31;
inline bool MessageInfo::has_payorderresponse() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MessageInfo::set_has_payorderresponse() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MessageInfo::clear_has_payorderresponse() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MessageInfo::clear_payorderresponse() {
  if (payorderresponse_ != NULL) payorderresponse_->::PayOrderResponse::Clear();
  clear_has_payorderresponse();
}
inline const ::PayOrderResponse& MessageInfo::payorderresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.payOrderResponse)
  return payorderresponse_ != NULL ? *payorderresponse_ : *default_instance_->payorderresponse_;
}
inline ::PayOrderResponse* MessageInfo::mutable_payorderresponse() {
  set_has_payorderresponse();
  if (payorderresponse_ == NULL) payorderresponse_ = new ::PayOrderResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.payOrderResponse)
  return payorderresponse_;
}
inline ::PayOrderResponse* MessageInfo::release_payorderresponse() {
  clear_has_payorderresponse();
  ::PayOrderResponse* temp = payorderresponse_;
  payorderresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_payorderresponse(::PayOrderResponse* payorderresponse) {
  delete payorderresponse_;
  payorderresponse_ = payorderresponse;
  if (payorderresponse) {
    set_has_payorderresponse();
  } else {
    clear_has_payorderresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.payOrderResponse)
}

// optional .AuthorizationRequest authorizationRequest = 32;
inline bool MessageInfo::has_authorizationrequest() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MessageInfo::set_has_authorizationrequest() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MessageInfo::clear_has_authorizationrequest() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MessageInfo::clear_authorizationrequest() {
  if (authorizationrequest_ != NULL) authorizationrequest_->::AuthorizationRequest::Clear();
  clear_has_authorizationrequest();
}
inline const ::AuthorizationRequest& MessageInfo::authorizationrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.authorizationRequest)
  return authorizationrequest_ != NULL ? *authorizationrequest_ : *default_instance_->authorizationrequest_;
}
inline ::AuthorizationRequest* MessageInfo::mutable_authorizationrequest() {
  set_has_authorizationrequest();
  if (authorizationrequest_ == NULL) authorizationrequest_ = new ::AuthorizationRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.authorizationRequest)
  return authorizationrequest_;
}
inline ::AuthorizationRequest* MessageInfo::release_authorizationrequest() {
  clear_has_authorizationrequest();
  ::AuthorizationRequest* temp = authorizationrequest_;
  authorizationrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_authorizationrequest(::AuthorizationRequest* authorizationrequest) {
  delete authorizationrequest_;
  authorizationrequest_ = authorizationrequest;
  if (authorizationrequest) {
    set_has_authorizationrequest();
  } else {
    clear_has_authorizationrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.authorizationRequest)
}

// optional .AuthorizationResponse authorizationResponse = 36;
inline bool MessageInfo::has_authorizationresponse() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_authorizationresponse() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MessageInfo::clear_has_authorizationresponse() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MessageInfo::clear_authorizationresponse() {
  if (authorizationresponse_ != NULL) authorizationresponse_->::AuthorizationResponse::Clear();
  clear_has_authorizationresponse();
}
inline const ::AuthorizationResponse& MessageInfo::authorizationresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.authorizationResponse)
  return authorizationresponse_ != NULL ? *authorizationresponse_ : *default_instance_->authorizationresponse_;
}
inline ::AuthorizationResponse* MessageInfo::mutable_authorizationresponse() {
  set_has_authorizationresponse();
  if (authorizationresponse_ == NULL) authorizationresponse_ = new ::AuthorizationResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.authorizationResponse)
  return authorizationresponse_;
}
inline ::AuthorizationResponse* MessageInfo::release_authorizationresponse() {
  clear_has_authorizationresponse();
  ::AuthorizationResponse* temp = authorizationresponse_;
  authorizationresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_authorizationresponse(::AuthorizationResponse* authorizationresponse) {
  delete authorizationresponse_;
  authorizationresponse_ = authorizationresponse;
  if (authorizationresponse) {
    set_has_authorizationresponse();
  } else {
    clear_has_authorizationresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.authorizationResponse)
}

// optional .PayResultRequest payResultRequest = 33;
inline bool MessageInfo::has_payresultrequest() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MessageInfo::set_has_payresultrequest() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MessageInfo::clear_has_payresultrequest() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MessageInfo::clear_payresultrequest() {
  if (payresultrequest_ != NULL) payresultrequest_->::PayResultRequest::Clear();
  clear_has_payresultrequest();
}
inline const ::PayResultRequest& MessageInfo::payresultrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.payResultRequest)
  return payresultrequest_ != NULL ? *payresultrequest_ : *default_instance_->payresultrequest_;
}
inline ::PayResultRequest* MessageInfo::mutable_payresultrequest() {
  set_has_payresultrequest();
  if (payresultrequest_ == NULL) payresultrequest_ = new ::PayResultRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.payResultRequest)
  return payresultrequest_;
}
inline ::PayResultRequest* MessageInfo::release_payresultrequest() {
  clear_has_payresultrequest();
  ::PayResultRequest* temp = payresultrequest_;
  payresultrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_payresultrequest(::PayResultRequest* payresultrequest) {
  delete payresultrequest_;
  payresultrequest_ = payresultrequest;
  if (payresultrequest) {
    set_has_payresultrequest();
  } else {
    clear_has_payresultrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.payResultRequest)
}

// optional .PayResultResponse PayResultResponse = 34;
inline bool MessageInfo::has_payresultresponse() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MessageInfo::set_has_payresultresponse() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MessageInfo::clear_has_payresultresponse() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MessageInfo::clear_payresultresponse() {
  if (payresultresponse_ != NULL) payresultresponse_->::PayResultResponse::Clear();
  clear_has_payresultresponse();
}
inline const ::PayResultResponse& MessageInfo::payresultresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.PayResultResponse)
  return payresultresponse_ != NULL ? *payresultresponse_ : *default_instance_->payresultresponse_;
}
inline ::PayResultResponse* MessageInfo::mutable_payresultresponse() {
  set_has_payresultresponse();
  if (payresultresponse_ == NULL) payresultresponse_ = new ::PayResultResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.PayResultResponse)
  return payresultresponse_;
}
inline ::PayResultResponse* MessageInfo::release_payresultresponse() {
  clear_has_payresultresponse();
  ::PayResultResponse* temp = payresultresponse_;
  payresultresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_payresultresponse(::PayResultResponse* payresultresponse) {
  delete payresultresponse_;
  payresultresponse_ = payresultresponse;
  if (payresultresponse) {
    set_has_payresultresponse();
  } else {
    clear_has_payresultresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.PayResultResponse)
}

// optional .UserInfoResponse userInfoResponse = 35;
inline bool MessageInfo::has_userinforesponse() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MessageInfo::set_has_userinforesponse() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MessageInfo::clear_has_userinforesponse() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MessageInfo::clear_userinforesponse() {
  if (userinforesponse_ != NULL) userinforesponse_->::UserInfoResponse::Clear();
  clear_has_userinforesponse();
}
inline const ::UserInfoResponse& MessageInfo::userinforesponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.userInfoResponse)
  return userinforesponse_ != NULL ? *userinforesponse_ : *default_instance_->userinforesponse_;
}
inline ::UserInfoResponse* MessageInfo::mutable_userinforesponse() {
  set_has_userinforesponse();
  if (userinforesponse_ == NULL) userinforesponse_ = new ::UserInfoResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.userInfoResponse)
  return userinforesponse_;
}
inline ::UserInfoResponse* MessageInfo::release_userinforesponse() {
  clear_has_userinforesponse();
  ::UserInfoResponse* temp = userinforesponse_;
  userinforesponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_userinforesponse(::UserInfoResponse* userinforesponse) {
  delete userinforesponse_;
  userinforesponse_ = userinforesponse;
  if (userinforesponse) {
    set_has_userinforesponse();
  } else {
    clear_has_userinforesponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.userInfoResponse)
}

// optional .GoldCoinListRequest goldCoinListRequest = 37;
inline bool MessageInfo::has_goldcoinlistrequest() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MessageInfo::set_has_goldcoinlistrequest() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MessageInfo::clear_has_goldcoinlistrequest() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MessageInfo::clear_goldcoinlistrequest() {
  if (goldcoinlistrequest_ != NULL) goldcoinlistrequest_->::GoldCoinListRequest::Clear();
  clear_has_goldcoinlistrequest();
}
inline const ::GoldCoinListRequest& MessageInfo::goldcoinlistrequest() const {
  // @@protoc_insertion_point(field_get:MessageInfo.goldCoinListRequest)
  return goldcoinlistrequest_ != NULL ? *goldcoinlistrequest_ : *default_instance_->goldcoinlistrequest_;
}
inline ::GoldCoinListRequest* MessageInfo::mutable_goldcoinlistrequest() {
  set_has_goldcoinlistrequest();
  if (goldcoinlistrequest_ == NULL) goldcoinlistrequest_ = new ::GoldCoinListRequest;
  // @@protoc_insertion_point(field_mutable:MessageInfo.goldCoinListRequest)
  return goldcoinlistrequest_;
}
inline ::GoldCoinListRequest* MessageInfo::release_goldcoinlistrequest() {
  clear_has_goldcoinlistrequest();
  ::GoldCoinListRequest* temp = goldcoinlistrequest_;
  goldcoinlistrequest_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_goldcoinlistrequest(::GoldCoinListRequest* goldcoinlistrequest) {
  delete goldcoinlistrequest_;
  goldcoinlistrequest_ = goldcoinlistrequest;
  if (goldcoinlistrequest) {
    set_has_goldcoinlistrequest();
  } else {
    clear_has_goldcoinlistrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.goldCoinListRequest)
}

// optional .GoldCoinListResponse goldCoinListResponse = 38;
inline bool MessageInfo::has_goldcoinlistresponse() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MessageInfo::set_has_goldcoinlistresponse() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MessageInfo::clear_has_goldcoinlistresponse() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MessageInfo::clear_goldcoinlistresponse() {
  if (goldcoinlistresponse_ != NULL) goldcoinlistresponse_->::GoldCoinListResponse::Clear();
  clear_has_goldcoinlistresponse();
}
inline const ::GoldCoinListResponse& MessageInfo::goldcoinlistresponse() const {
  // @@protoc_insertion_point(field_get:MessageInfo.goldCoinListResponse)
  return goldcoinlistresponse_ != NULL ? *goldcoinlistresponse_ : *default_instance_->goldcoinlistresponse_;
}
inline ::GoldCoinListResponse* MessageInfo::mutable_goldcoinlistresponse() {
  set_has_goldcoinlistresponse();
  if (goldcoinlistresponse_ == NULL) goldcoinlistresponse_ = new ::GoldCoinListResponse;
  // @@protoc_insertion_point(field_mutable:MessageInfo.goldCoinListResponse)
  return goldcoinlistresponse_;
}
inline ::GoldCoinListResponse* MessageInfo::release_goldcoinlistresponse() {
  clear_has_goldcoinlistresponse();
  ::GoldCoinListResponse* temp = goldcoinlistresponse_;
  goldcoinlistresponse_ = NULL;
  return temp;
}
inline void MessageInfo::set_allocated_goldcoinlistresponse(::GoldCoinListResponse* goldcoinlistresponse) {
  delete goldcoinlistresponse_;
  goldcoinlistresponse_ = goldcoinlistresponse;
  if (goldcoinlistresponse) {
    set_has_goldcoinlistresponse();
  } else {
    clear_has_goldcoinlistresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:MessageInfo.goldCoinListResponse)
}

// -------------------------------------------------------------------

// Basic

// optional string channel = 1;
inline bool Basic::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Basic::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Basic::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Basic::clear_channel() {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& Basic::channel() const {
  // @@protoc_insertion_point(field_get:Basic.channel)
  return *channel_;
}
inline void Basic::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set:Basic.channel)
}
inline void Basic::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
  // @@protoc_insertion_point(field_set_char:Basic.channel)
}
inline void Basic::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Basic.channel)
}
inline ::std::string* Basic::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Basic.channel)
  return channel_;
}
inline ::std::string* Basic::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Basic::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Basic.channel)
}

// -------------------------------------------------------------------

// RegisterRequest

// optional string mac = 1;
inline bool RegisterRequest::has_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& RegisterRequest::mac() const {
  // @@protoc_insertion_point(field_get:RegisterRequest.mac)
  return *mac_;
}
inline void RegisterRequest::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:RegisterRequest.mac)
}
inline void RegisterRequest::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequest.mac)
}
inline void RegisterRequest::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequest.mac)
}
inline ::std::string* RegisterRequest::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRequest.mac)
  return mac_;
}
inline ::std::string* RegisterRequest::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterRequest::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.mac)
}

// optional string userPayId = 2;
inline bool RegisterRequest::has_userpayid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_userpayid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_userpayid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_userpayid() {
  if (userpayid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_->clear();
  }
  clear_has_userpayid();
}
inline const ::std::string& RegisterRequest::userpayid() const {
  // @@protoc_insertion_point(field_get:RegisterRequest.userPayId)
  return *userpayid_;
}
inline void RegisterRequest::set_userpayid(const ::std::string& value) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(value);
  // @@protoc_insertion_point(field_set:RegisterRequest.userPayId)
}
inline void RegisterRequest::set_userpayid(const char* value) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequest.userPayId)
}
inline void RegisterRequest::set_userpayid(const char* value, size_t size) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequest.userPayId)
}
inline ::std::string* RegisterRequest::mutable_userpayid() {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRequest.userPayId)
  return userpayid_;
}
inline ::std::string* RegisterRequest::release_userpayid() {
  clear_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userpayid_;
    userpayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterRequest::set_allocated_userpayid(::std::string* userpayid) {
  if (userpayid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userpayid_;
  }
  if (userpayid) {
    set_has_userpayid();
    userpayid_ = userpayid;
  } else {
    clear_has_userpayid();
    userpayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.userPayId)
}

// optional string device = 3;
inline bool RegisterRequest::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::set_has_device() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequest::clear_has_device() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequest::clear_device() {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& RegisterRequest::device() const {
  // @@protoc_insertion_point(field_get:RegisterRequest.device)
  return *device_;
}
inline void RegisterRequest::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set:RegisterRequest.device)
}
inline void RegisterRequest::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequest.device)
}
inline void RegisterRequest::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequest.device)
}
inline ::std::string* RegisterRequest::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRequest.device)
  return device_;
}
inline ::std::string* RegisterRequest::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterRequest::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRequest.device)
}

// -------------------------------------------------------------------

// RegisterResponse

// required .UserInfo userInfo = 1;
inline bool RegisterResponse::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponse::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponse::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& RegisterResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* RegisterResponse::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:RegisterResponse.userInfo)
  return userinfo_;
}
inline ::UserInfo* RegisterResponse::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void RegisterResponse::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterResponse.userInfo)
}

// optional int32 propOverdue = 2;
inline bool RegisterResponse::has_propoverdue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponse::set_has_propoverdue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResponse::clear_has_propoverdue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResponse::clear_propoverdue() {
  propoverdue_ = 0;
  clear_has_propoverdue();
}
inline ::google::protobuf::int32 RegisterResponse::propoverdue() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.propOverdue)
  return propoverdue_;
}
inline void RegisterResponse::set_propoverdue(::google::protobuf::int32 value) {
  set_has_propoverdue();
  propoverdue_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponse.propOverdue)
}

// repeated .SignReward signRewards = 3;
inline int RegisterResponse::signrewards_size() const {
  return signrewards_.size();
}
inline void RegisterResponse::clear_signrewards() {
  signrewards_.Clear();
}
inline const ::SignReward& RegisterResponse::signrewards(int index) const {
  // @@protoc_insertion_point(field_get:RegisterResponse.signRewards)
  return signrewards_.Get(index);
}
inline ::SignReward* RegisterResponse::mutable_signrewards(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterResponse.signRewards)
  return signrewards_.Mutable(index);
}
inline ::SignReward* RegisterResponse::add_signrewards() {
  // @@protoc_insertion_point(field_add:RegisterResponse.signRewards)
  return signrewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SignReward >&
RegisterResponse::signrewards() const {
  // @@protoc_insertion_point(field_list:RegisterResponse.signRewards)
  return signrewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::SignReward >*
RegisterResponse::mutable_signrewards() {
  // @@protoc_insertion_point(field_mutable_list:RegisterResponse.signRewards)
  return &signrewards_;
}

// optional .RenewMerchandise renewMerchandise = 4;
inline bool RegisterResponse::has_renewmerchandise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterResponse::set_has_renewmerchandise() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterResponse::clear_has_renewmerchandise() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterResponse::clear_renewmerchandise() {
  if (renewmerchandise_ != NULL) renewmerchandise_->::RenewMerchandise::Clear();
  clear_has_renewmerchandise();
}
inline const ::RenewMerchandise& RegisterResponse::renewmerchandise() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.renewMerchandise)
  return renewmerchandise_ != NULL ? *renewmerchandise_ : *default_instance_->renewmerchandise_;
}
inline ::RenewMerchandise* RegisterResponse::mutable_renewmerchandise() {
  set_has_renewmerchandise();
  if (renewmerchandise_ == NULL) renewmerchandise_ = new ::RenewMerchandise;
  // @@protoc_insertion_point(field_mutable:RegisterResponse.renewMerchandise)
  return renewmerchandise_;
}
inline ::RenewMerchandise* RegisterResponse::release_renewmerchandise() {
  clear_has_renewmerchandise();
  ::RenewMerchandise* temp = renewmerchandise_;
  renewmerchandise_ = NULL;
  return temp;
}
inline void RegisterResponse::set_allocated_renewmerchandise(::RenewMerchandise* renewmerchandise) {
  delete renewmerchandise_;
  renewmerchandise_ = renewmerchandise;
  if (renewmerchandise) {
    set_has_renewmerchandise();
  } else {
    clear_has_renewmerchandise();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterResponse.renewMerchandise)
}

// -------------------------------------------------------------------

// RenewMerchandise

// required string id = 1;
inline bool RenewMerchandise::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RenewMerchandise::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RenewMerchandise::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RenewMerchandise::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RenewMerchandise::id() const {
  // @@protoc_insertion_point(field_get:RenewMerchandise.id)
  return *id_;
}
inline void RenewMerchandise::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:RenewMerchandise.id)
}
inline void RenewMerchandise::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RenewMerchandise.id)
}
inline void RenewMerchandise::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RenewMerchandise.id)
}
inline ::std::string* RenewMerchandise::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RenewMerchandise.id)
  return id_;
}
inline ::std::string* RenewMerchandise::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RenewMerchandise::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RenewMerchandise.id)
}

// optional int32 gold = 2;
inline bool RenewMerchandise::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RenewMerchandise::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RenewMerchandise::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RenewMerchandise::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 RenewMerchandise::gold() const {
  // @@protoc_insertion_point(field_get:RenewMerchandise.gold)
  return gold_;
}
inline void RenewMerchandise::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:RenewMerchandise.gold)
}

// optional int32 price = 3;
inline bool RenewMerchandise::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RenewMerchandise::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RenewMerchandise::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RenewMerchandise::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 RenewMerchandise::price() const {
  // @@protoc_insertion_point(field_get:RenewMerchandise.price)
  return price_;
}
inline void RenewMerchandise::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:RenewMerchandise.price)
}

// -------------------------------------------------------------------

// SignReward

// required int32 day = 1;
inline bool SignReward::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignReward::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignReward::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignReward::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SignReward::day() const {
  // @@protoc_insertion_point(field_get:SignReward.day)
  return day_;
}
inline void SignReward::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:SignReward.day)
}

// required int32 gold = 2;
inline bool SignReward::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignReward::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignReward::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignReward::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 SignReward::gold() const {
  // @@protoc_insertion_point(field_get:SignReward.gold)
  return gold_;
}
inline void SignReward::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:SignReward.gold)
}

// required int32 status = 3;
inline bool SignReward::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignReward::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignReward::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignReward::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SignReward::status() const {
  // @@protoc_insertion_point(field_get:SignReward.status)
  return status_;
}
inline void SignReward::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:SignReward.status)
}

// -------------------------------------------------------------------

// SkinChooseRequest

// required int32 skin = 1;
inline bool SkinChooseRequest::has_skin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkinChooseRequest::set_has_skin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkinChooseRequest::clear_has_skin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkinChooseRequest::clear_skin() {
  skin_ = 0;
  clear_has_skin();
}
inline ::google::protobuf::int32 SkinChooseRequest::skin() const {
  // @@protoc_insertion_point(field_get:SkinChooseRequest.skin)
  return skin_;
}
inline void SkinChooseRequest::set_skin(::google::protobuf::int32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:SkinChooseRequest.skin)
}

// -------------------------------------------------------------------

// NickNameRandomRespone

// required string nickname = 1;
inline bool NickNameRandomRespone::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NickNameRandomRespone::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NickNameRandomRespone::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NickNameRandomRespone::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& NickNameRandomRespone::nickname() const {
  // @@protoc_insertion_point(field_get:NickNameRandomRespone.nickname)
  return *nickname_;
}
inline void NickNameRandomRespone::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:NickNameRandomRespone.nickname)
}
inline void NickNameRandomRespone::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NickNameRandomRespone.nickname)
}
inline void NickNameRandomRespone::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NickNameRandomRespone.nickname)
}
inline ::std::string* NickNameRandomRespone::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NickNameRandomRespone.nickname)
  return nickname_;
}
inline ::std::string* NickNameRandomRespone::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NickNameRandomRespone::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NickNameRandomRespone.nickname)
}

// -------------------------------------------------------------------

// MatchStartResponse

// required .RoomInfo roomInfo = 1;
inline bool MatchStartResponse::has_roominfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStartResponse::set_has_roominfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStartResponse::clear_has_roominfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStartResponse::clear_roominfo() {
  if (roominfo_ != NULL) roominfo_->::RoomInfo::Clear();
  clear_has_roominfo();
}
inline const ::RoomInfo& MatchStartResponse::roominfo() const {
  // @@protoc_insertion_point(field_get:MatchStartResponse.roomInfo)
  return roominfo_ != NULL ? *roominfo_ : *default_instance_->roominfo_;
}
inline ::RoomInfo* MatchStartResponse::mutable_roominfo() {
  set_has_roominfo();
  if (roominfo_ == NULL) roominfo_ = new ::RoomInfo;
  // @@protoc_insertion_point(field_mutable:MatchStartResponse.roomInfo)
  return roominfo_;
}
inline ::RoomInfo* MatchStartResponse::release_roominfo() {
  clear_has_roominfo();
  ::RoomInfo* temp = roominfo_;
  roominfo_ = NULL;
  return temp;
}
inline void MatchStartResponse::set_allocated_roominfo(::RoomInfo* roominfo) {
  delete roominfo_;
  roominfo_ = roominfo;
  if (roominfo) {
    set_has_roominfo();
  } else {
    clear_has_roominfo();
  }
  // @@protoc_insertion_point(field_set_allocated:MatchStartResponse.roomInfo)
}

// -------------------------------------------------------------------

// PLayerListResponse

// repeated .Player allPlayers = 1;
inline int PLayerListResponse::allplayers_size() const {
  return allplayers_.size();
}
inline void PLayerListResponse::clear_allplayers() {
  allplayers_.Clear();
}
inline const ::Player& PLayerListResponse::allplayers(int index) const {
  // @@protoc_insertion_point(field_get:PLayerListResponse.allPlayers)
  return allplayers_.Get(index);
}
inline ::Player* PLayerListResponse::mutable_allplayers(int index) {
  // @@protoc_insertion_point(field_mutable:PLayerListResponse.allPlayers)
  return allplayers_.Mutable(index);
}
inline ::Player* PLayerListResponse::add_allplayers() {
  // @@protoc_insertion_point(field_add:PLayerListResponse.allPlayers)
  return allplayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
PLayerListResponse::allplayers() const {
  // @@protoc_insertion_point(field_list:PLayerListResponse.allPlayers)
  return allplayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
PLayerListResponse::mutable_allplayers() {
  // @@protoc_insertion_point(field_mutable_list:PLayerListResponse.allPlayers)
  return &allplayers_;
}

// repeated .Player removePlayers = 2;
inline int PLayerListResponse::removeplayers_size() const {
  return removeplayers_.size();
}
inline void PLayerListResponse::clear_removeplayers() {
  removeplayers_.Clear();
}
inline const ::Player& PLayerListResponse::removeplayers(int index) const {
  // @@protoc_insertion_point(field_get:PLayerListResponse.removePlayers)
  return removeplayers_.Get(index);
}
inline ::Player* PLayerListResponse::mutable_removeplayers(int index) {
  // @@protoc_insertion_point(field_mutable:PLayerListResponse.removePlayers)
  return removeplayers_.Mutable(index);
}
inline ::Player* PLayerListResponse::add_removeplayers() {
  // @@protoc_insertion_point(field_add:PLayerListResponse.removePlayers)
  return removeplayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
PLayerListResponse::removeplayers() const {
  // @@protoc_insertion_point(field_list:PLayerListResponse.removePlayers)
  return removeplayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
PLayerListResponse::mutable_removeplayers() {
  // @@protoc_insertion_point(field_mutable_list:PLayerListResponse.removePlayers)
  return &removeplayers_;
}

// repeated .Player newPlayers = 3;
inline int PLayerListResponse::newplayers_size() const {
  return newplayers_.size();
}
inline void PLayerListResponse::clear_newplayers() {
  newplayers_.Clear();
}
inline const ::Player& PLayerListResponse::newplayers(int index) const {
  // @@protoc_insertion_point(field_get:PLayerListResponse.newPlayers)
  return newplayers_.Get(index);
}
inline ::Player* PLayerListResponse::mutable_newplayers(int index) {
  // @@protoc_insertion_point(field_mutable:PLayerListResponse.newPlayers)
  return newplayers_.Mutable(index);
}
inline ::Player* PLayerListResponse::add_newplayers() {
  // @@protoc_insertion_point(field_add:PLayerListResponse.newPlayers)
  return newplayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
PLayerListResponse::newplayers() const {
  // @@protoc_insertion_point(field_list:PLayerListResponse.newPlayers)
  return newplayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
PLayerListResponse::mutable_newplayers() {
  // @@protoc_insertion_point(field_mutable_list:PLayerListResponse.newPlayers)
  return &newplayers_;
}

// repeated .Player changePlayers = 4;
inline int PLayerListResponse::changeplayers_size() const {
  return changeplayers_.size();
}
inline void PLayerListResponse::clear_changeplayers() {
  changeplayers_.Clear();
}
inline const ::Player& PLayerListResponse::changeplayers(int index) const {
  // @@protoc_insertion_point(field_get:PLayerListResponse.changePlayers)
  return changeplayers_.Get(index);
}
inline ::Player* PLayerListResponse::mutable_changeplayers(int index) {
  // @@protoc_insertion_point(field_mutable:PLayerListResponse.changePlayers)
  return changeplayers_.Mutable(index);
}
inline ::Player* PLayerListResponse::add_changeplayers() {
  // @@protoc_insertion_point(field_add:PLayerListResponse.changePlayers)
  return changeplayers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
PLayerListResponse::changeplayers() const {
  // @@protoc_insertion_point(field_list:PLayerListResponse.changePlayers)
  return changeplayers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
PLayerListResponse::mutable_changeplayers() {
  // @@protoc_insertion_point(field_mutable_list:PLayerListResponse.changePlayers)
  return &changeplayers_;
}

// -------------------------------------------------------------------

// FoodChangeResponse

// required int32 type = 1;
inline bool FoodChangeResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FoodChangeResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FoodChangeResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FoodChangeResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FoodChangeResponse::type() const {
  // @@protoc_insertion_point(field_get:FoodChangeResponse.type)
  return type_;
}
inline void FoodChangeResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:FoodChangeResponse.type)
}

// repeated .FoodArea foodAreas = 2;
inline int FoodChangeResponse::foodareas_size() const {
  return foodareas_.size();
}
inline void FoodChangeResponse::clear_foodareas() {
  foodareas_.Clear();
}
inline const ::FoodArea& FoodChangeResponse::foodareas(int index) const {
  // @@protoc_insertion_point(field_get:FoodChangeResponse.foodAreas)
  return foodareas_.Get(index);
}
inline ::FoodArea* FoodChangeResponse::mutable_foodareas(int index) {
  // @@protoc_insertion_point(field_mutable:FoodChangeResponse.foodAreas)
  return foodareas_.Mutable(index);
}
inline ::FoodArea* FoodChangeResponse::add_foodareas() {
  // @@protoc_insertion_point(field_add:FoodChangeResponse.foodAreas)
  return foodareas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
FoodChangeResponse::foodareas() const {
  // @@protoc_insertion_point(field_list:FoodChangeResponse.foodAreas)
  return foodareas_;
}
inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
FoodChangeResponse::mutable_foodareas() {
  // @@protoc_insertion_point(field_mutable_list:FoodChangeResponse.foodAreas)
  return &foodareas_;
}

// -------------------------------------------------------------------

// FoodArea

// optional int32 areaId = 1;
inline bool FoodArea::has_areaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FoodArea::set_has_areaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FoodArea::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FoodArea::clear_areaid() {
  areaid_ = 0;
  clear_has_areaid();
}
inline ::google::protobuf::int32 FoodArea::areaid() const {
  // @@protoc_insertion_point(field_get:FoodArea.areaId)
  return areaid_;
}
inline void FoodArea::set_areaid(::google::protobuf::int32 value) {
  set_has_areaid();
  areaid_ = value;
  // @@protoc_insertion_point(field_set:FoodArea.areaId)
}

// optional int32 x = 2;
inline bool FoodArea::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FoodArea::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FoodArea::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FoodArea::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 FoodArea::x() const {
  // @@protoc_insertion_point(field_get:FoodArea.x)
  return x_;
}
inline void FoodArea::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:FoodArea.x)
}

// optional int32 y = 3;
inline bool FoodArea::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FoodArea::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FoodArea::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FoodArea::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 FoodArea::y() const {
  // @@protoc_insertion_point(field_get:FoodArea.y)
  return y_;
}
inline void FoodArea::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:FoodArea.y)
}

// optional int32 width = 4;
inline bool FoodArea::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FoodArea::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FoodArea::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FoodArea::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 FoodArea::width() const {
  // @@protoc_insertion_point(field_get:FoodArea.width)
  return width_;
}
inline void FoodArea::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:FoodArea.width)
}

// optional int32 height = 5;
inline bool FoodArea::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FoodArea::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FoodArea::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FoodArea::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 FoodArea::height() const {
  // @@protoc_insertion_point(field_get:FoodArea.height)
  return height_;
}
inline void FoodArea::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:FoodArea.height)
}

// repeated .Food foods = 6;
inline int FoodArea::foods_size() const {
  return foods_.size();
}
inline void FoodArea::clear_foods() {
  foods_.Clear();
}
inline const ::Food& FoodArea::foods(int index) const {
  // @@protoc_insertion_point(field_get:FoodArea.foods)
  return foods_.Get(index);
}
inline ::Food* FoodArea::mutable_foods(int index) {
  // @@protoc_insertion_point(field_mutable:FoodArea.foods)
  return foods_.Mutable(index);
}
inline ::Food* FoodArea::add_foods() {
  // @@protoc_insertion_point(field_add:FoodArea.foods)
  return foods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Food >&
FoodArea::foods() const {
  // @@protoc_insertion_point(field_list:FoodArea.foods)
  return foods_;
}
inline ::google::protobuf::RepeatedPtrField< ::Food >*
FoodArea::mutable_foods() {
  // @@protoc_insertion_point(field_mutable_list:FoodArea.foods)
  return &foods_;
}

// -------------------------------------------------------------------

// RemainTimeResponse

// required int32 remain = 1;
inline bool RemainTimeResponse::has_remain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemainTimeResponse::set_has_remain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemainTimeResponse::clear_has_remain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemainTimeResponse::clear_remain() {
  remain_ = 0;
  clear_has_remain();
}
inline ::google::protobuf::int32 RemainTimeResponse::remain() const {
  // @@protoc_insertion_point(field_get:RemainTimeResponse.remain)
  return remain_;
}
inline void RemainTimeResponse::set_remain(::google::protobuf::int32 value) {
  set_has_remain();
  remain_ = value;
  // @@protoc_insertion_point(field_set:RemainTimeResponse.remain)
}

// -------------------------------------------------------------------

// RankListResponse

// repeated .RankItem rankItems = 1;
inline int RankListResponse::rankitems_size() const {
  return rankitems_.size();
}
inline void RankListResponse::clear_rankitems() {
  rankitems_.Clear();
}
inline const ::RankItem& RankListResponse::rankitems(int index) const {
  // @@protoc_insertion_point(field_get:RankListResponse.rankItems)
  return rankitems_.Get(index);
}
inline ::RankItem* RankListResponse::mutable_rankitems(int index) {
  // @@protoc_insertion_point(field_mutable:RankListResponse.rankItems)
  return rankitems_.Mutable(index);
}
inline ::RankItem* RankListResponse::add_rankitems() {
  // @@protoc_insertion_point(field_add:RankListResponse.rankItems)
  return rankitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
RankListResponse::rankitems() const {
  // @@protoc_insertion_point(field_list:RankListResponse.rankItems)
  return rankitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
RankListResponse::mutable_rankitems() {
  // @@protoc_insertion_point(field_mutable_list:RankListResponse.rankItems)
  return &rankitems_;
}

// -------------------------------------------------------------------

// GameEndResponse

// repeated .RankItem rankItems = 1;
inline int GameEndResponse::rankitems_size() const {
  return rankitems_.size();
}
inline void GameEndResponse::clear_rankitems() {
  rankitems_.Clear();
}
inline const ::RankItem& GameEndResponse::rankitems(int index) const {
  // @@protoc_insertion_point(field_get:GameEndResponse.rankItems)
  return rankitems_.Get(index);
}
inline ::RankItem* GameEndResponse::mutable_rankitems(int index) {
  // @@protoc_insertion_point(field_mutable:GameEndResponse.rankItems)
  return rankitems_.Mutable(index);
}
inline ::RankItem* GameEndResponse::add_rankitems() {
  // @@protoc_insertion_point(field_add:GameEndResponse.rankItems)
  return rankitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
GameEndResponse::rankitems() const {
  // @@protoc_insertion_point(field_list:GameEndResponse.rankItems)
  return rankitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
GameEndResponse::mutable_rankitems() {
  // @@protoc_insertion_point(field_mutable_list:GameEndResponse.rankItems)
  return &rankitems_;
}

// -------------------------------------------------------------------

// PlayerSkillRequest

// required int32 skill = 1;
inline bool PlayerSkillRequest::has_skill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSkillRequest::set_has_skill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSkillRequest::clear_has_skill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSkillRequest::clear_skill() {
  skill_ = 0;
  clear_has_skill();
}
inline ::google::protobuf::int32 PlayerSkillRequest::skill() const {
  // @@protoc_insertion_point(field_get:PlayerSkillRequest.skill)
  return skill_;
}
inline void PlayerSkillRequest::set_skill(::google::protobuf::int32 value) {
  set_has_skill();
  skill_ = value;
  // @@protoc_insertion_point(field_set:PlayerSkillRequest.skill)
}

// -------------------------------------------------------------------

// PlayerSkillResponse

// repeated .PlayerSkill playerSkills = 1;
inline int PlayerSkillResponse::playerskills_size() const {
  return playerskills_.size();
}
inline void PlayerSkillResponse::clear_playerskills() {
  playerskills_.Clear();
}
inline const ::PlayerSkill& PlayerSkillResponse::playerskills(int index) const {
  // @@protoc_insertion_point(field_get:PlayerSkillResponse.playerSkills)
  return playerskills_.Get(index);
}
inline ::PlayerSkill* PlayerSkillResponse::mutable_playerskills(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerSkillResponse.playerSkills)
  return playerskills_.Mutable(index);
}
inline ::PlayerSkill* PlayerSkillResponse::add_playerskills() {
  // @@protoc_insertion_point(field_add:PlayerSkillResponse.playerSkills)
  return playerskills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerSkill >&
PlayerSkillResponse::playerskills() const {
  // @@protoc_insertion_point(field_list:PlayerSkillResponse.playerSkills)
  return playerskills_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerSkill >*
PlayerSkillResponse::mutable_playerskills() {
  // @@protoc_insertion_point(field_mutable_list:PlayerSkillResponse.playerSkills)
  return &playerskills_;
}

// -------------------------------------------------------------------

// PlayerSkill

// optional int32 skill = 1;
inline bool PlayerSkill::has_skill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSkill::set_has_skill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSkill::clear_has_skill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSkill::clear_skill() {
  skill_ = 0;
  clear_has_skill();
}
inline ::google::protobuf::int32 PlayerSkill::skill() const {
  // @@protoc_insertion_point(field_get:PlayerSkill.skill)
  return skill_;
}
inline void PlayerSkill::set_skill(::google::protobuf::int32 value) {
  set_has_skill();
  skill_ = value;
  // @@protoc_insertion_point(field_set:PlayerSkill.skill)
}

// optional .Player player = 2;
inline bool PlayerSkill::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSkill::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSkill::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSkill::clear_player() {
  if (player_ != NULL) player_->::Player::Clear();
  clear_has_player();
}
inline const ::Player& PlayerSkill::player() const {
  // @@protoc_insertion_point(field_get:PlayerSkill.player)
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::Player* PlayerSkill::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::Player;
  // @@protoc_insertion_point(field_mutable:PlayerSkill.player)
  return player_;
}
inline ::Player* PlayerSkill::release_player() {
  clear_has_player();
  ::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline void PlayerSkill::set_allocated_player(::Player* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerSkill.player)
}

// optional int32 state = 3;
inline bool PlayerSkill::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSkill::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSkill::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSkill::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 PlayerSkill::state() const {
  // @@protoc_insertion_point(field_get:PlayerSkill.state)
  return state_;
}
inline void PlayerSkill::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:PlayerSkill.state)
}

// repeated .MapEntity map = 4;
inline int PlayerSkill::map_size() const {
  return map_.size();
}
inline void PlayerSkill::clear_map() {
  map_.Clear();
}
inline const ::MapEntity& PlayerSkill::map(int index) const {
  // @@protoc_insertion_point(field_get:PlayerSkill.map)
  return map_.Get(index);
}
inline ::MapEntity* PlayerSkill::mutable_map(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerSkill.map)
  return map_.Mutable(index);
}
inline ::MapEntity* PlayerSkill::add_map() {
  // @@protoc_insertion_point(field_add:PlayerSkill.map)
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntity >&
PlayerSkill::map() const {
  // @@protoc_insertion_point(field_list:PlayerSkill.map)
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntity >*
PlayerSkill::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:PlayerSkill.map)
  return &map_;
}

// optional int32 duration = 5;
inline bool PlayerSkill::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerSkill::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerSkill::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerSkill::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 PlayerSkill::duration() const {
  // @@protoc_insertion_point(field_get:PlayerSkill.duration)
  return duration_;
}
inline void PlayerSkill::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:PlayerSkill.duration)
}

// -------------------------------------------------------------------

// MapEntity

// required string key = 1;
inline bool MapEntity::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEntity::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEntity::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEntity::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MapEntity::key() const {
  // @@protoc_insertion_point(field_get:MapEntity.key)
  return *key_;
}
inline void MapEntity::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:MapEntity.key)
}
inline void MapEntity::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntity.key)
}
inline void MapEntity::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntity.key)
}
inline ::std::string* MapEntity::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapEntity.key)
  return key_;
}
inline ::std::string* MapEntity::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapEntity::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntity.key)
}

// required string value = 2;
inline bool MapEntity::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapEntity::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapEntity::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapEntity::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& MapEntity::value() const {
  // @@protoc_insertion_point(field_get:MapEntity.value)
  return *value_;
}
inline void MapEntity::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:MapEntity.value)
}
inline void MapEntity::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntity.value)
}
inline void MapEntity::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntity.value)
}
inline ::std::string* MapEntity::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapEntity.value)
  return value_;
}
inline ::std::string* MapEntity::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapEntity::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntity.value)
}

// -------------------------------------------------------------------

// RankItem

// required int32 rank = 1;
inline bool RankItem::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankItem::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankItem::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankItem::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 RankItem::rank() const {
  // @@protoc_insertion_point(field_get:RankItem.rank)
  return rank_;
}
inline void RankItem::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:RankItem.rank)
}

// optional .UserInfo userInfo = 2;
inline bool RankItem::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankItem::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankItem::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankItem::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& RankItem::userinfo() const {
  // @@protoc_insertion_point(field_get:RankItem.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* RankItem::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:RankItem.userInfo)
  return userinfo_;
}
inline ::UserInfo* RankItem::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void RankItem::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:RankItem.userInfo)
}

// optional int32 weight = 3;
inline bool RankItem::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankItem::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankItem::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankItem::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 RankItem::weight() const {
  // @@protoc_insertion_point(field_get:RankItem.weight)
  return weight_;
}
inline void RankItem::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:RankItem.weight)
}

// optional int32 reward = 4;
inline bool RankItem::has_reward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankItem::set_has_reward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankItem::clear_has_reward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankItem::clear_reward() {
  reward_ = 0;
  clear_has_reward();
}
inline ::google::protobuf::int32 RankItem::reward() const {
  // @@protoc_insertion_point(field_get:RankItem.reward)
  return reward_;
}
inline void RankItem::set_reward(::google::protobuf::int32 value) {
  set_has_reward();
  reward_ = value;
  // @@protoc_insertion_point(field_set:RankItem.reward)
}

// -------------------------------------------------------------------

// CellVector

// required int32 cellId = 1;
inline bool CellVector::has_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellVector::set_has_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellVector::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellVector::clear_cellid() {
  cellid_ = 0;
  clear_has_cellid();
}
inline ::google::protobuf::int32 CellVector::cellid() const {
  // @@protoc_insertion_point(field_get:CellVector.cellId)
  return cellid_;
}
inline void CellVector::set_cellid(::google::protobuf::int32 value) {
  set_has_cellid();
  cellid_ = value;
  // @@protoc_insertion_point(field_set:CellVector.cellId)
}

// optional int32 angle = 2;
inline bool CellVector::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellVector::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellVector::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellVector::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline ::google::protobuf::int32 CellVector::angle() const {
  // @@protoc_insertion_point(field_get:CellVector.angle)
  return angle_;
}
inline void CellVector::set_angle(::google::protobuf::int32 value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:CellVector.angle)
}

// -------------------------------------------------------------------

// PlayerOperationRequest

// repeated .CellVector cellVector = 1;
inline int PlayerOperationRequest::cellvector_size() const {
  return cellvector_.size();
}
inline void PlayerOperationRequest::clear_cellvector() {
  cellvector_.Clear();
}
inline const ::CellVector& PlayerOperationRequest::cellvector(int index) const {
  // @@protoc_insertion_point(field_get:PlayerOperationRequest.cellVector)
  return cellvector_.Get(index);
}
inline ::CellVector* PlayerOperationRequest::mutable_cellvector(int index) {
  // @@protoc_insertion_point(field_mutable:PlayerOperationRequest.cellVector)
  return cellvector_.Mutable(index);
}
inline ::CellVector* PlayerOperationRequest::add_cellvector() {
  // @@protoc_insertion_point(field_add:PlayerOperationRequest.cellVector)
  return cellvector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CellVector >&
PlayerOperationRequest::cellvector() const {
  // @@protoc_insertion_point(field_list:PlayerOperationRequest.cellVector)
  return cellvector_;
}
inline ::google::protobuf::RepeatedPtrField< ::CellVector >*
PlayerOperationRequest::mutable_cellvector() {
  // @@protoc_insertion_point(field_mutable_list:PlayerOperationRequest.cellVector)
  return &cellvector_;
}

// -------------------------------------------------------------------

// UserInfo

// required int32 uid = 1;
inline bool UserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 UserInfo::uid() const {
  // @@protoc_insertion_point(field_get:UserInfo.uid)
  return uid_;
}
inline void UserInfo::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.uid)
}

// optional int32 skin = 2;
inline bool UserInfo::has_skin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_skin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_skin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_skin() {
  skin_ = 0;
  clear_has_skin();
}
inline ::google::protobuf::int32 UserInfo::skin() const {
  // @@protoc_insertion_point(field_get:UserInfo.skin)
  return skin_;
}
inline void UserInfo::set_skin(::google::protobuf::int32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.skin)
}

// optional string nickname = 3;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  // @@protoc_insertion_point(field_get:UserInfo.nickname)
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserInfo.nickname)
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserInfo.nickname)
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserInfo.nickname)
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.nickname)
}

// optional string account = 4;
inline bool UserInfo::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UserInfo::account() const {
  // @@protoc_insertion_point(field_get:UserInfo.account)
  return *account_;
}
inline void UserInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set:UserInfo.account)
}
inline void UserInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserInfo.account)
}
inline void UserInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserInfo.account)
}
inline ::std::string* UserInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserInfo.account)
  return account_;
}
inline ::std::string* UserInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.account)
}

// optional .UltimateSkill ultimateSkill = 5;
inline bool UserInfo::has_ultimateskill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_ultimateskill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_ultimateskill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_ultimateskill() {
  if (ultimateskill_ != NULL) ultimateskill_->::UltimateSkill::Clear();
  clear_has_ultimateskill();
}
inline const ::UltimateSkill& UserInfo::ultimateskill() const {
  // @@protoc_insertion_point(field_get:UserInfo.ultimateSkill)
  return ultimateskill_ != NULL ? *ultimateskill_ : *default_instance_->ultimateskill_;
}
inline ::UltimateSkill* UserInfo::mutable_ultimateskill() {
  set_has_ultimateskill();
  if (ultimateskill_ == NULL) ultimateskill_ = new ::UltimateSkill;
  // @@protoc_insertion_point(field_mutable:UserInfo.ultimateSkill)
  return ultimateskill_;
}
inline ::UltimateSkill* UserInfo::release_ultimateskill() {
  clear_has_ultimateskill();
  ::UltimateSkill* temp = ultimateskill_;
  ultimateskill_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_ultimateskill(::UltimateSkill* ultimateskill) {
  delete ultimateskill_;
  ultimateskill_ = ultimateskill;
  if (ultimateskill) {
    set_has_ultimateskill();
  } else {
    clear_has_ultimateskill();
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfo.ultimateSkill)
}

// optional int32 gold = 6;
inline bool UserInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 UserInfo::gold() const {
  // @@protoc_insertion_point(field_get:UserInfo.gold)
  return gold_;
}
inline void UserInfo::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.gold)
}

// optional int32 stamina = 7;
inline bool UserInfo::has_stamina() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_stamina() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_stamina() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_stamina() {
  stamina_ = 0;
  clear_has_stamina();
}
inline ::google::protobuf::int32 UserInfo::stamina() const {
  // @@protoc_insertion_point(field_get:UserInfo.stamina)
  return stamina_;
}
inline void UserInfo::set_stamina(::google::protobuf::int32 value) {
  set_has_stamina();
  stamina_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.stamina)
}

// optional int32 maxStamina = 8;
inline bool UserInfo::has_maxstamina() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_maxstamina() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_maxstamina() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_maxstamina() {
  maxstamina_ = 0;
  clear_has_maxstamina();
}
inline ::google::protobuf::int32 UserInfo::maxstamina() const {
  // @@protoc_insertion_point(field_get:UserInfo.maxStamina)
  return maxstamina_;
}
inline void UserInfo::set_maxstamina(::google::protobuf::int32 value) {
  set_has_maxstamina();
  maxstamina_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.maxStamina)
}

// optional int32 countdown = 9;
inline bool UserInfo::has_countdown() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_countdown() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_countdown() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_countdown() {
  countdown_ = 0;
  clear_has_countdown();
}
inline ::google::protobuf::int32 UserInfo::countdown() const {
  // @@protoc_insertion_point(field_get:UserInfo.countdown)
  return countdown_;
}
inline void UserInfo::set_countdown(::google::protobuf::int32 value) {
  set_has_countdown();
  countdown_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.countdown)
}

// optional int32 privilege = 10;
inline bool UserInfo::has_privilege() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_privilege() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_privilege() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_privilege() {
  privilege_ = 0;
  clear_has_privilege();
}
inline ::google::protobuf::int32 UserInfo::privilege() const {
  // @@protoc_insertion_point(field_get:UserInfo.privilege)
  return privilege_;
}
inline void UserInfo::set_privilege(::google::protobuf::int32 value) {
  set_has_privilege();
  privilege_ = value;
  // @@protoc_insertion_point(field_set:UserInfo.privilege)
}

// -------------------------------------------------------------------

// Food

// required int32 id = 1;
inline bool Food::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Food::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Food::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Food::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Food::id() const {
  // @@protoc_insertion_point(field_get:Food.id)
  return id_;
}
inline void Food::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Food.id)
}

// optional int32 skin = 2;
inline bool Food::has_skin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Food::set_has_skin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Food::clear_has_skin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Food::clear_skin() {
  skin_ = 0;
  clear_has_skin();
}
inline ::google::protobuf::int32 Food::skin() const {
  // @@protoc_insertion_point(field_get:Food.skin)
  return skin_;
}
inline void Food::set_skin(::google::protobuf::int32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:Food.skin)
}

// optional int32 x = 3;
inline bool Food::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Food::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Food::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Food::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Food::x() const {
  // @@protoc_insertion_point(field_get:Food.x)
  return x_;
}
inline void Food::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Food.x)
}

// optional int32 y = 4;
inline bool Food::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Food::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Food::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Food::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Food::y() const {
  // @@protoc_insertion_point(field_get:Food.y)
  return y_;
}
inline void Food::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Food.y)
}

// -------------------------------------------------------------------

// Cell

// required int32 id = 1;
inline bool Cell::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Cell::id() const {
  // @@protoc_insertion_point(field_get:Cell.id)
  return id_;
}
inline void Cell::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cell.id)
}

// optional int32 x = 2;
inline bool Cell::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cell::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cell::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cell::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Cell::x() const {
  // @@protoc_insertion_point(field_get:Cell.x)
  return x_;
}
inline void Cell::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Cell.x)
}

// optional int32 y = 3;
inline bool Cell::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cell::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cell::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cell::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Cell::y() const {
  // @@protoc_insertion_point(field_get:Cell.y)
  return y_;
}
inline void Cell::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Cell.y)
}

// optional int32 radius = 4;
inline bool Cell::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cell::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cell::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cell::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 Cell::radius() const {
  // @@protoc_insertion_point(field_get:Cell.radius)
  return radius_;
}
inline void Cell::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:Cell.radius)
}

// optional int32 speed = 5;
inline bool Cell::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Cell::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Cell::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Cell::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Cell::speed() const {
  // @@protoc_insertion_point(field_get:Cell.speed)
  return speed_;
}
inline void Cell::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Cell.speed)
}

// optional int32 angle = 6;
inline bool Cell::has_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cell::set_has_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Cell::clear_has_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Cell::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline ::google::protobuf::int32 Cell::angle() const {
  // @@protoc_insertion_point(field_get:Cell.angle)
  return angle_;
}
inline void Cell::set_angle(::google::protobuf::int32 value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:Cell.angle)
}

// optional int32 fromId = 7;
inline bool Cell::has_fromid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Cell::set_has_fromid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Cell::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Cell::clear_fromid() {
  fromid_ = 0;
  clear_has_fromid();
}
inline ::google::protobuf::int32 Cell::fromid() const {
  // @@protoc_insertion_point(field_get:Cell.fromId)
  return fromid_;
}
inline void Cell::set_fromid(::google::protobuf::int32 value) {
  set_has_fromid();
  fromid_ = value;
  // @@protoc_insertion_point(field_set:Cell.fromId)
}

// optional int32 mergeId = 8;
inline bool Cell::has_mergeid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Cell::set_has_mergeid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Cell::clear_has_mergeid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Cell::clear_mergeid() {
  mergeid_ = 0;
  clear_has_mergeid();
}
inline ::google::protobuf::int32 Cell::mergeid() const {
  // @@protoc_insertion_point(field_get:Cell.mergeId)
  return mergeid_;
}
inline void Cell::set_mergeid(::google::protobuf::int32 value) {
  set_has_mergeid();
  mergeid_ = value;
  // @@protoc_insertion_point(field_set:Cell.mergeId)
}

// optional int32 status = 9;
inline bool Cell::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Cell::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Cell::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Cell::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Cell::status() const {
  // @@protoc_insertion_point(field_get:Cell.status)
  return status_;
}
inline void Cell::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Cell.status)
}

// repeated .FoodArea magnetFoods = 10;
inline int Cell::magnetfoods_size() const {
  return magnetfoods_.size();
}
inline void Cell::clear_magnetfoods() {
  magnetfoods_.Clear();
}
inline const ::FoodArea& Cell::magnetfoods(int index) const {
  // @@protoc_insertion_point(field_get:Cell.magnetFoods)
  return magnetfoods_.Get(index);
}
inline ::FoodArea* Cell::mutable_magnetfoods(int index) {
  // @@protoc_insertion_point(field_mutable:Cell.magnetFoods)
  return magnetfoods_.Mutable(index);
}
inline ::FoodArea* Cell::add_magnetfoods() {
  // @@protoc_insertion_point(field_add:Cell.magnetFoods)
  return magnetfoods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
Cell::magnetfoods() const {
  // @@protoc_insertion_point(field_list:Cell.magnetFoods)
  return magnetfoods_;
}
inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
Cell::mutable_magnetfoods() {
  // @@protoc_insertion_point(field_mutable_list:Cell.magnetFoods)
  return &magnetfoods_;
}

// -------------------------------------------------------------------

// Player

// required .UserInfo userInfo = 1;
inline bool Player::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& Player::userinfo() const {
  // @@protoc_insertion_point(field_get:Player.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* Player::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:Player.userInfo)
  return userinfo_;
}
inline ::UserInfo* Player::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void Player::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Player.userInfo)
}

// optional int32 weight = 2;
inline bool Player::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 Player::weight() const {
  // @@protoc_insertion_point(field_get:Player.weight)
  return weight_;
}
inline void Player::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:Player.weight)
}

// repeated .Cell cells = 3;
inline int Player::cells_size() const {
  return cells_.size();
}
inline void Player::clear_cells() {
  cells_.Clear();
}
inline const ::Cell& Player::cells(int index) const {
  // @@protoc_insertion_point(field_get:Player.cells)
  return cells_.Get(index);
}
inline ::Cell* Player::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:Player.cells)
  return cells_.Mutable(index);
}
inline ::Cell* Player::add_cells() {
  // @@protoc_insertion_point(field_add:Player.cells)
  return cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cell >&
Player::cells() const {
  // @@protoc_insertion_point(field_list:Player.cells)
  return cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cell >*
Player::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:Player.cells)
  return &cells_;
}

// optional int32 status = 4;
inline bool Player::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Player::status() const {
  // @@protoc_insertion_point(field_get:Player.status)
  return status_;
}
inline void Player::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Player.status)
}

// optional int32 ultimateSkillProgress = 5;
inline bool Player::has_ultimateskillprogress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player::set_has_ultimateskillprogress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player::clear_has_ultimateskillprogress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player::clear_ultimateskillprogress() {
  ultimateskillprogress_ = 0;
  clear_has_ultimateskillprogress();
}
inline ::google::protobuf::int32 Player::ultimateskillprogress() const {
  // @@protoc_insertion_point(field_get:Player.ultimateSkillProgress)
  return ultimateskillprogress_;
}
inline void Player::set_ultimateskillprogress(::google::protobuf::int32 value) {
  set_has_ultimateskillprogress();
  ultimateskillprogress_ = value;
  // @@protoc_insertion_point(field_set:Player.ultimateSkillProgress)
}

// optional .UserInfo beKilledUserInfo = 6;
inline bool Player::has_bekilleduserinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player::set_has_bekilleduserinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player::clear_has_bekilleduserinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player::clear_bekilleduserinfo() {
  if (bekilleduserinfo_ != NULL) bekilleduserinfo_->::UserInfo::Clear();
  clear_has_bekilleduserinfo();
}
inline const ::UserInfo& Player::bekilleduserinfo() const {
  // @@protoc_insertion_point(field_get:Player.beKilledUserInfo)
  return bekilleduserinfo_ != NULL ? *bekilleduserinfo_ : *default_instance_->bekilleduserinfo_;
}
inline ::UserInfo* Player::mutable_bekilleduserinfo() {
  set_has_bekilleduserinfo();
  if (bekilleduserinfo_ == NULL) bekilleduserinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:Player.beKilledUserInfo)
  return bekilleduserinfo_;
}
inline ::UserInfo* Player::release_bekilleduserinfo() {
  clear_has_bekilleduserinfo();
  ::UserInfo* temp = bekilleduserinfo_;
  bekilleduserinfo_ = NULL;
  return temp;
}
inline void Player::set_allocated_bekilleduserinfo(::UserInfo* bekilleduserinfo) {
  delete bekilleduserinfo_;
  bekilleduserinfo_ = bekilleduserinfo;
  if (bekilleduserinfo) {
    set_has_bekilleduserinfo();
  } else {
    clear_has_bekilleduserinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Player.beKilledUserInfo)
}

// optional .SuperRenewInfo superRenewInfo = 7;
inline bool Player::has_superrenewinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player::set_has_superrenewinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player::clear_has_superrenewinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player::clear_superrenewinfo() {
  if (superrenewinfo_ != NULL) superrenewinfo_->::SuperRenewInfo::Clear();
  clear_has_superrenewinfo();
}
inline const ::SuperRenewInfo& Player::superrenewinfo() const {
  // @@protoc_insertion_point(field_get:Player.superRenewInfo)
  return superrenewinfo_ != NULL ? *superrenewinfo_ : *default_instance_->superrenewinfo_;
}
inline ::SuperRenewInfo* Player::mutable_superrenewinfo() {
  set_has_superrenewinfo();
  if (superrenewinfo_ == NULL) superrenewinfo_ = new ::SuperRenewInfo;
  // @@protoc_insertion_point(field_mutable:Player.superRenewInfo)
  return superrenewinfo_;
}
inline ::SuperRenewInfo* Player::release_superrenewinfo() {
  clear_has_superrenewinfo();
  ::SuperRenewInfo* temp = superrenewinfo_;
  superrenewinfo_ = NULL;
  return temp;
}
inline void Player::set_allocated_superrenewinfo(::SuperRenewInfo* superrenewinfo) {
  delete superrenewinfo_;
  superrenewinfo_ = superrenewinfo;
  if (superrenewinfo) {
    set_has_superrenewinfo();
  } else {
    clear_has_superrenewinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Player.superRenewInfo)
}

// -------------------------------------------------------------------

// SuperRenewInfo

// optional int32 gold = 1;
inline bool SuperRenewInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuperRenewInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuperRenewInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuperRenewInfo::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 SuperRenewInfo::gold() const {
  // @@protoc_insertion_point(field_get:SuperRenewInfo.gold)
  return gold_;
}
inline void SuperRenewInfo::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:SuperRenewInfo.gold)
}

// optional int32 weight = 2;
inline bool SuperRenewInfo::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuperRenewInfo::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuperRenewInfo::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuperRenewInfo::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 SuperRenewInfo::weight() const {
  // @@protoc_insertion_point(field_get:SuperRenewInfo.weight)
  return weight_;
}
inline void SuperRenewInfo::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:SuperRenewInfo.weight)
}

// optional int32 percent = 3;
inline bool SuperRenewInfo::has_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuperRenewInfo::set_has_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuperRenewInfo::clear_has_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuperRenewInfo::clear_percent() {
  percent_ = 0;
  clear_has_percent();
}
inline ::google::protobuf::int32 SuperRenewInfo::percent() const {
  // @@protoc_insertion_point(field_get:SuperRenewInfo.percent)
  return percent_;
}
inline void SuperRenewInfo::set_percent(::google::protobuf::int32 value) {
  set_has_percent();
  percent_ = value;
  // @@protoc_insertion_point(field_set:SuperRenewInfo.percent)
}

// -------------------------------------------------------------------

// RoomInfo

// required int32 width = 1;
inline bool RoomInfo::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 RoomInfo::width() const {
  // @@protoc_insertion_point(field_get:RoomInfo.width)
  return width_;
}
inline void RoomInfo::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.width)
}

// required int32 height = 2;
inline bool RoomInfo::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 RoomInfo::height() const {
  // @@protoc_insertion_point(field_get:RoomInfo.height)
  return height_;
}
inline void RoomInfo::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.height)
}

// optional int32 remainTime = 3;
inline bool RoomInfo::has_remaintime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_remaintime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 RoomInfo::remaintime() const {
  // @@protoc_insertion_point(field_get:RoomInfo.remainTime)
  return remaintime_;
}
inline void RoomInfo::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.remainTime)
}

// optional int32 foodRadius = 4;
inline bool RoomInfo::has_foodradius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInfo::set_has_foodradius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInfo::clear_has_foodradius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInfo::clear_foodradius() {
  foodradius_ = 0;
  clear_has_foodradius();
}
inline ::google::protobuf::int32 RoomInfo::foodradius() const {
  // @@protoc_insertion_point(field_get:RoomInfo.foodRadius)
  return foodradius_;
}
inline void RoomInfo::set_foodradius(::google::protobuf::int32 value) {
  set_has_foodradius();
  foodradius_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.foodRadius)
}

// repeated .Player players = 5;
inline int RoomInfo::players_size() const {
  return players_.size();
}
inline void RoomInfo::clear_players() {
  players_.Clear();
}
inline const ::Player& RoomInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.players)
  return players_.Get(index);
}
inline ::Player* RoomInfo::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.players)
  return players_.Mutable(index);
}
inline ::Player* RoomInfo::add_players() {
  // @@protoc_insertion_point(field_add:RoomInfo.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
RoomInfo::players() const {
  // @@protoc_insertion_point(field_list:RoomInfo.players)
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
RoomInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.players)
  return &players_;
}

// repeated .FoodArea foodAreas = 6;
inline int RoomInfo::foodareas_size() const {
  return foodareas_.size();
}
inline void RoomInfo::clear_foodareas() {
  foodareas_.Clear();
}
inline const ::FoodArea& RoomInfo::foodareas(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.foodAreas)
  return foodareas_.Get(index);
}
inline ::FoodArea* RoomInfo::mutable_foodareas(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.foodAreas)
  return foodareas_.Mutable(index);
}
inline ::FoodArea* RoomInfo::add_foodareas() {
  // @@protoc_insertion_point(field_add:RoomInfo.foodAreas)
  return foodareas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FoodArea >&
RoomInfo::foodareas() const {
  // @@protoc_insertion_point(field_list:RoomInfo.foodAreas)
  return foodareas_;
}
inline ::google::protobuf::RepeatedPtrField< ::FoodArea >*
RoomInfo::mutable_foodareas() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.foodAreas)
  return &foodareas_;
}

// repeated .RankItem rankItems = 7;
inline int RoomInfo::rankitems_size() const {
  return rankitems_.size();
}
inline void RoomInfo::clear_rankitems() {
  rankitems_.Clear();
}
inline const ::RankItem& RoomInfo::rankitems(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.rankItems)
  return rankitems_.Get(index);
}
inline ::RankItem* RoomInfo::mutable_rankitems(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.rankItems)
  return rankitems_.Mutable(index);
}
inline ::RankItem* RoomInfo::add_rankitems() {
  // @@protoc_insertion_point(field_add:RoomInfo.rankItems)
  return rankitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RankItem >&
RoomInfo::rankitems() const {
  // @@protoc_insertion_point(field_list:RoomInfo.rankItems)
  return rankitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::RankItem >*
RoomInfo::mutable_rankitems() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.rankItems)
  return &rankitems_;
}

// repeated .Asylum asylums = 8;
inline int RoomInfo::asylums_size() const {
  return asylums_.size();
}
inline void RoomInfo::clear_asylums() {
  asylums_.Clear();
}
inline const ::Asylum& RoomInfo::asylums(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.asylums)
  return asylums_.Get(index);
}
inline ::Asylum* RoomInfo::mutable_asylums(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.asylums)
  return asylums_.Mutable(index);
}
inline ::Asylum* RoomInfo::add_asylums() {
  // @@protoc_insertion_point(field_add:RoomInfo.asylums)
  return asylums_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Asylum >&
RoomInfo::asylums() const {
  // @@protoc_insertion_point(field_list:RoomInfo.asylums)
  return asylums_;
}
inline ::google::protobuf::RepeatedPtrField< ::Asylum >*
RoomInfo::mutable_asylums() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.asylums)
  return &asylums_;
}

// -------------------------------------------------------------------

// GameStateResponse

// required int32 state = 1;
inline bool GameStateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStateResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 GameStateResponse::state() const {
  // @@protoc_insertion_point(field_get:GameStateResponse.state)
  return state_;
}
inline void GameStateResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:GameStateResponse.state)
}

// optional string roomId = 2;
inline bool GameStateResponse::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStateResponse::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStateResponse::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStateResponse::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& GameStateResponse::roomid() const {
  // @@protoc_insertion_point(field_get:GameStateResponse.roomId)
  return *roomid_;
}
inline void GameStateResponse::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set:GameStateResponse.roomId)
}
inline void GameStateResponse::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameStateResponse.roomId)
}
inline void GameStateResponse::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameStateResponse.roomId)
}
inline ::std::string* GameStateResponse::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameStateResponse.roomId)
  return roomid_;
}
inline ::std::string* GameStateResponse::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameStateResponse::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameStateResponse.roomId)
}

// -------------------------------------------------------------------

// GameReadyRequest

// optional string roomId = 1;
inline bool GameReadyRequest::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameReadyRequest::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameReadyRequest::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameReadyRequest::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& GameReadyRequest::roomid() const {
  // @@protoc_insertion_point(field_get:GameReadyRequest.roomId)
  return *roomid_;
}
inline void GameReadyRequest::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set:GameReadyRequest.roomId)
}
inline void GameReadyRequest::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameReadyRequest.roomId)
}
inline void GameReadyRequest::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameReadyRequest.roomId)
}
inline ::std::string* GameReadyRequest::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    roomid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameReadyRequest.roomId)
  return roomid_;
}
inline ::std::string* GameReadyRequest::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameReadyRequest::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameReadyRequest.roomId)
}

// -------------------------------------------------------------------

// UltimateSkillChooseRequest

// optional int32 ultimateSkill = 1;
inline bool UltimateSkillChooseRequest::has_ultimateskill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UltimateSkillChooseRequest::set_has_ultimateskill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UltimateSkillChooseRequest::clear_has_ultimateskill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UltimateSkillChooseRequest::clear_ultimateskill() {
  ultimateskill_ = 0;
  clear_has_ultimateskill();
}
inline ::google::protobuf::int32 UltimateSkillChooseRequest::ultimateskill() const {
  // @@protoc_insertion_point(field_get:UltimateSkillChooseRequest.ultimateSkill)
  return ultimateskill_;
}
inline void UltimateSkillChooseRequest::set_ultimateskill(::google::protobuf::int32 value) {
  set_has_ultimateskill();
  ultimateskill_ = value;
  // @@protoc_insertion_point(field_set:UltimateSkillChooseRequest.ultimateSkill)
}

// -------------------------------------------------------------------

// UltimateSkillChooseResponse

// -------------------------------------------------------------------

// PlayerRenewalRequest

// optional int32 type = 1;
inline bool PlayerRenewalRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRenewalRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRenewalRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerRenewalRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlayerRenewalRequest::type() const {
  // @@protoc_insertion_point(field_get:PlayerRenewalRequest.type)
  return type_;
}
inline void PlayerRenewalRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:PlayerRenewalRequest.type)
}

// -------------------------------------------------------------------

// PlayerRenewalResponse

// -------------------------------------------------------------------

// Asylum

// required int32 id = 1;
inline bool Asylum::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Asylum::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Asylum::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Asylum::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Asylum::id() const {
  // @@protoc_insertion_point(field_get:Asylum.id)
  return id_;
}
inline void Asylum::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Asylum.id)
}

// optional int32 skin = 2;
inline bool Asylum::has_skin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Asylum::set_has_skin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Asylum::clear_has_skin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Asylum::clear_skin() {
  skin_ = 0;
  clear_has_skin();
}
inline ::google::protobuf::int32 Asylum::skin() const {
  // @@protoc_insertion_point(field_get:Asylum.skin)
  return skin_;
}
inline void Asylum::set_skin(::google::protobuf::int32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:Asylum.skin)
}

// optional float x = 3;
inline bool Asylum::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Asylum::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Asylum::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Asylum::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Asylum::x() const {
  // @@protoc_insertion_point(field_get:Asylum.x)
  return x_;
}
inline void Asylum::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Asylum.x)
}

// optional float y = 4;
inline bool Asylum::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Asylum::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Asylum::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Asylum::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Asylum::y() const {
  // @@protoc_insertion_point(field_get:Asylum.y)
  return y_;
}
inline void Asylum::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Asylum.y)
}

// optional float radius = 5;
inline bool Asylum::has_radius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Asylum::set_has_radius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Asylum::clear_has_radius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Asylum::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Asylum::radius() const {
  // @@protoc_insertion_point(field_get:Asylum.radius)
  return radius_;
}
inline void Asylum::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:Asylum.radius)
}

// -------------------------------------------------------------------

// Prop

// required int32 id = 1;
inline bool Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Prop::id() const {
  // @@protoc_insertion_point(field_get:Prop.id)
  return id_;
}
inline void Prop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Prop.id)
}

// required int32 remainDay = 2;
inline bool Prop::has_remainday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prop::set_has_remainday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prop::clear_has_remainday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prop::clear_remainday() {
  remainday_ = 0;
  clear_has_remainday();
}
inline ::google::protobuf::int32 Prop::remainday() const {
  // @@protoc_insertion_point(field_get:Prop.remainDay)
  return remainday_;
}
inline void Prop::set_remainday(::google::protobuf::int32 value) {
  set_has_remainday();
  remainday_ = value;
  // @@protoc_insertion_point(field_set:Prop.remainDay)
}

// -------------------------------------------------------------------

// BackpackResponse

// repeated .Prop skins = 1;
inline int BackpackResponse::skins_size() const {
  return skins_.size();
}
inline void BackpackResponse::clear_skins() {
  skins_.Clear();
}
inline const ::Prop& BackpackResponse::skins(int index) const {
  // @@protoc_insertion_point(field_get:BackpackResponse.skins)
  return skins_.Get(index);
}
inline ::Prop* BackpackResponse::mutable_skins(int index) {
  // @@protoc_insertion_point(field_mutable:BackpackResponse.skins)
  return skins_.Mutable(index);
}
inline ::Prop* BackpackResponse::add_skins() {
  // @@protoc_insertion_point(field_add:BackpackResponse.skins)
  return skins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Prop >&
BackpackResponse::skins() const {
  // @@protoc_insertion_point(field_list:BackpackResponse.skins)
  return skins_;
}
inline ::google::protobuf::RepeatedPtrField< ::Prop >*
BackpackResponse::mutable_skins() {
  // @@protoc_insertion_point(field_mutable_list:BackpackResponse.skins)
  return &skins_;
}

// repeated .Prop skills = 2;
inline int BackpackResponse::skills_size() const {
  return skills_.size();
}
inline void BackpackResponse::clear_skills() {
  skills_.Clear();
}
inline const ::Prop& BackpackResponse::skills(int index) const {
  // @@protoc_insertion_point(field_get:BackpackResponse.skills)
  return skills_.Get(index);
}
inline ::Prop* BackpackResponse::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:BackpackResponse.skills)
  return skills_.Mutable(index);
}
inline ::Prop* BackpackResponse::add_skills() {
  // @@protoc_insertion_point(field_add:BackpackResponse.skills)
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Prop >&
BackpackResponse::skills() const {
  // @@protoc_insertion_point(field_list:BackpackResponse.skills)
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::Prop >*
BackpackResponse::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:BackpackResponse.skills)
  return &skills_;
}

// -------------------------------------------------------------------

// SkinMerchandise

// required string id = 1;
inline bool SkinMerchandise::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkinMerchandise::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkinMerchandise::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkinMerchandise::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SkinMerchandise::id() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.id)
  return *id_;
}
inline void SkinMerchandise::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:SkinMerchandise.id)
}
inline void SkinMerchandise::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkinMerchandise.id)
}
inline void SkinMerchandise::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkinMerchandise.id)
}
inline ::std::string* SkinMerchandise::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkinMerchandise.id)
  return id_;
}
inline ::std::string* SkinMerchandise::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkinMerchandise::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkinMerchandise.id)
}

// required string name = 2;
inline bool SkinMerchandise::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkinMerchandise::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkinMerchandise::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkinMerchandise::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SkinMerchandise::name() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.name)
  return *name_;
}
inline void SkinMerchandise::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:SkinMerchandise.name)
}
inline void SkinMerchandise::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkinMerchandise.name)
}
inline void SkinMerchandise::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkinMerchandise.name)
}
inline ::std::string* SkinMerchandise::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkinMerchandise.name)
  return name_;
}
inline ::std::string* SkinMerchandise::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkinMerchandise::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkinMerchandise.name)
}

// required int32 propId = 3;
inline bool SkinMerchandise::has_propid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkinMerchandise::set_has_propid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkinMerchandise::clear_has_propid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkinMerchandise::clear_propid() {
  propid_ = 0;
  clear_has_propid();
}
inline ::google::protobuf::int32 SkinMerchandise::propid() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.propId)
  return propid_;
}
inline void SkinMerchandise::set_propid(::google::protobuf::int32 value) {
  set_has_propid();
  propid_ = value;
  // @@protoc_insertion_point(field_set:SkinMerchandise.propId)
}

// required int32 price = 4;
inline bool SkinMerchandise::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkinMerchandise::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkinMerchandise::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkinMerchandise::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 SkinMerchandise::price() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.price)
  return price_;
}
inline void SkinMerchandise::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:SkinMerchandise.price)
}

// required int32 availableDays = 5;
inline bool SkinMerchandise::has_availabledays() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkinMerchandise::set_has_availabledays() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkinMerchandise::clear_has_availabledays() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkinMerchandise::clear_availabledays() {
  availabledays_ = 0;
  clear_has_availabledays();
}
inline ::google::protobuf::int32 SkinMerchandise::availabledays() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.availableDays)
  return availabledays_;
}
inline void SkinMerchandise::set_availabledays(::google::protobuf::int32 value) {
  set_has_availabledays();
  availabledays_ = value;
  // @@protoc_insertion_point(field_set:SkinMerchandise.availableDays)
}

// optional string description = 6;
inline bool SkinMerchandise::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkinMerchandise::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkinMerchandise::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkinMerchandise::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SkinMerchandise::description() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.description)
  return *description_;
}
inline void SkinMerchandise::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:SkinMerchandise.description)
}
inline void SkinMerchandise::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkinMerchandise.description)
}
inline void SkinMerchandise::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkinMerchandise.description)
}
inline ::std::string* SkinMerchandise::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkinMerchandise.description)
  return description_;
}
inline ::std::string* SkinMerchandise::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkinMerchandise::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkinMerchandise.description)
}

// optional int32 tag = 7;
inline bool SkinMerchandise::has_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkinMerchandise::set_has_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkinMerchandise::clear_has_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkinMerchandise::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 SkinMerchandise::tag() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.tag)
  return tag_;
}
inline void SkinMerchandise::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SkinMerchandise.tag)
}

// optional int32 type = 8;
inline bool SkinMerchandise::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkinMerchandise::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkinMerchandise::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkinMerchandise::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SkinMerchandise::type() const {
  // @@protoc_insertion_point(field_get:SkinMerchandise.type)
  return type_;
}
inline void SkinMerchandise::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SkinMerchandise.type)
}

// -------------------------------------------------------------------

// SkillMerchandise

// required string id = 1;
inline bool SkillMerchandise::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillMerchandise::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillMerchandise::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillMerchandise::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SkillMerchandise::id() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.id)
  return *id_;
}
inline void SkillMerchandise::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:SkillMerchandise.id)
}
inline void SkillMerchandise::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkillMerchandise.id)
}
inline void SkillMerchandise::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkillMerchandise.id)
}
inline ::std::string* SkillMerchandise::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkillMerchandise.id)
  return id_;
}
inline ::std::string* SkillMerchandise::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkillMerchandise::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkillMerchandise.id)
}

// required string name = 2;
inline bool SkillMerchandise::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillMerchandise::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillMerchandise::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillMerchandise::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SkillMerchandise::name() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.name)
  return *name_;
}
inline void SkillMerchandise::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:SkillMerchandise.name)
}
inline void SkillMerchandise::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkillMerchandise.name)
}
inline void SkillMerchandise::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkillMerchandise.name)
}
inline ::std::string* SkillMerchandise::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkillMerchandise.name)
  return name_;
}
inline ::std::string* SkillMerchandise::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkillMerchandise::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkillMerchandise.name)
}

// required int32 propId = 3;
inline bool SkillMerchandise::has_propid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillMerchandise::set_has_propid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillMerchandise::clear_has_propid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillMerchandise::clear_propid() {
  propid_ = 0;
  clear_has_propid();
}
inline ::google::protobuf::int32 SkillMerchandise::propid() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.propId)
  return propid_;
}
inline void SkillMerchandise::set_propid(::google::protobuf::int32 value) {
  set_has_propid();
  propid_ = value;
  // @@protoc_insertion_point(field_set:SkillMerchandise.propId)
}

// required int32 price = 4;
inline bool SkillMerchandise::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillMerchandise::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillMerchandise::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillMerchandise::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 SkillMerchandise::price() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.price)
  return price_;
}
inline void SkillMerchandise::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:SkillMerchandise.price)
}

// required int32 availableDays = 5;
inline bool SkillMerchandise::has_availabledays() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillMerchandise::set_has_availabledays() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillMerchandise::clear_has_availabledays() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillMerchandise::clear_availabledays() {
  availabledays_ = 0;
  clear_has_availabledays();
}
inline ::google::protobuf::int32 SkillMerchandise::availabledays() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.availableDays)
  return availabledays_;
}
inline void SkillMerchandise::set_availabledays(::google::protobuf::int32 value) {
  set_has_availabledays();
  availabledays_ = value;
  // @@protoc_insertion_point(field_set:SkillMerchandise.availableDays)
}

// optional string description = 6;
inline bool SkillMerchandise::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillMerchandise::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillMerchandise::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillMerchandise::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SkillMerchandise::description() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.description)
  return *description_;
}
inline void SkillMerchandise::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:SkillMerchandise.description)
}
inline void SkillMerchandise::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:SkillMerchandise.description)
}
inline void SkillMerchandise::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SkillMerchandise.description)
}
inline ::std::string* SkillMerchandise::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SkillMerchandise.description)
  return description_;
}
inline ::std::string* SkillMerchandise::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SkillMerchandise::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SkillMerchandise.description)
}

// optional int32 foodId = 7;
inline bool SkillMerchandise::has_foodid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillMerchandise::set_has_foodid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillMerchandise::clear_has_foodid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillMerchandise::clear_foodid() {
  foodid_ = 0;
  clear_has_foodid();
}
inline ::google::protobuf::int32 SkillMerchandise::foodid() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.foodId)
  return foodid_;
}
inline void SkillMerchandise::set_foodid(::google::protobuf::int32 value) {
  set_has_foodid();
  foodid_ = value;
  // @@protoc_insertion_point(field_set:SkillMerchandise.foodId)
}

// required int32 type = 8;
inline bool SkillMerchandise::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillMerchandise::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillMerchandise::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillMerchandise::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SkillMerchandise::type() const {
  // @@protoc_insertion_point(field_get:SkillMerchandise.type)
  return type_;
}
inline void SkillMerchandise::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SkillMerchandise.type)
}

// -------------------------------------------------------------------

// ShopMerchandiseResponse

// repeated .SkinMerchandise skinMerchandises = 1;
inline int ShopMerchandiseResponse::skinmerchandises_size() const {
  return skinmerchandises_.size();
}
inline void ShopMerchandiseResponse::clear_skinmerchandises() {
  skinmerchandises_.Clear();
}
inline const ::SkinMerchandise& ShopMerchandiseResponse::skinmerchandises(int index) const {
  // @@protoc_insertion_point(field_get:ShopMerchandiseResponse.skinMerchandises)
  return skinmerchandises_.Get(index);
}
inline ::SkinMerchandise* ShopMerchandiseResponse::mutable_skinmerchandises(int index) {
  // @@protoc_insertion_point(field_mutable:ShopMerchandiseResponse.skinMerchandises)
  return skinmerchandises_.Mutable(index);
}
inline ::SkinMerchandise* ShopMerchandiseResponse::add_skinmerchandises() {
  // @@protoc_insertion_point(field_add:ShopMerchandiseResponse.skinMerchandises)
  return skinmerchandises_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkinMerchandise >&
ShopMerchandiseResponse::skinmerchandises() const {
  // @@protoc_insertion_point(field_list:ShopMerchandiseResponse.skinMerchandises)
  return skinmerchandises_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkinMerchandise >*
ShopMerchandiseResponse::mutable_skinmerchandises() {
  // @@protoc_insertion_point(field_mutable_list:ShopMerchandiseResponse.skinMerchandises)
  return &skinmerchandises_;
}

// repeated .SkillMerchandise skillMerchandises = 2;
inline int ShopMerchandiseResponse::skillmerchandises_size() const {
  return skillmerchandises_.size();
}
inline void ShopMerchandiseResponse::clear_skillmerchandises() {
  skillmerchandises_.Clear();
}
inline const ::SkillMerchandise& ShopMerchandiseResponse::skillmerchandises(int index) const {
  // @@protoc_insertion_point(field_get:ShopMerchandiseResponse.skillMerchandises)
  return skillmerchandises_.Get(index);
}
inline ::SkillMerchandise* ShopMerchandiseResponse::mutable_skillmerchandises(int index) {
  // @@protoc_insertion_point(field_mutable:ShopMerchandiseResponse.skillMerchandises)
  return skillmerchandises_.Mutable(index);
}
inline ::SkillMerchandise* ShopMerchandiseResponse::add_skillmerchandises() {
  // @@protoc_insertion_point(field_add:ShopMerchandiseResponse.skillMerchandises)
  return skillmerchandises_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillMerchandise >&
ShopMerchandiseResponse::skillmerchandises() const {
  // @@protoc_insertion_point(field_list:ShopMerchandiseResponse.skillMerchandises)
  return skillmerchandises_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillMerchandise >*
ShopMerchandiseResponse::mutable_skillmerchandises() {
  // @@protoc_insertion_point(field_mutable_list:ShopMerchandiseResponse.skillMerchandises)
  return &skillmerchandises_;
}

// -------------------------------------------------------------------

// BuyRequest

// required string id = 1;
inline bool BuyRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BuyRequest::id() const {
  // @@protoc_insertion_point(field_get:BuyRequest.id)
  return *id_;
}
inline void BuyRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:BuyRequest.id)
}
inline void BuyRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:BuyRequest.id)
}
inline void BuyRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BuyRequest.id)
}
inline ::std::string* BuyRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BuyRequest.id)
  return id_;
}
inline ::std::string* BuyRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BuyRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BuyRequest.id)
}

// -------------------------------------------------------------------

// UserChangedResponse

// required .UserInfo userInfo = 1;
inline bool UserChangedResponse::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserChangedResponse::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserChangedResponse::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserChangedResponse::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& UserChangedResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:UserChangedResponse.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* UserChangedResponse::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:UserChangedResponse.userInfo)
  return userinfo_;
}
inline ::UserInfo* UserChangedResponse::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserChangedResponse::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:UserChangedResponse.userInfo)
}

// -------------------------------------------------------------------

// UserInfoResponse

// required .UserInfo userInfo = 1;
inline bool UserInfoResponse::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoResponse::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoResponse::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoResponse::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& UserInfoResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:UserInfoResponse.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* UserInfoResponse::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:UserInfoResponse.userInfo)
  return userinfo_;
}
inline ::UserInfo* UserInfoResponse::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserInfoResponse::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:UserInfoResponse.userInfo)
}

// -------------------------------------------------------------------

// UltimateSkill

// required int32 id = 1;
inline bool UltimateSkill::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UltimateSkill::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UltimateSkill::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UltimateSkill::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UltimateSkill::id() const {
  // @@protoc_insertion_point(field_get:UltimateSkill.id)
  return id_;
}
inline void UltimateSkill::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:UltimateSkill.id)
}

// optional int32 foodId = 2;
inline bool UltimateSkill::has_foodid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UltimateSkill::set_has_foodid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UltimateSkill::clear_has_foodid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UltimateSkill::clear_foodid() {
  foodid_ = 0;
  clear_has_foodid();
}
inline ::google::protobuf::int32 UltimateSkill::foodid() const {
  // @@protoc_insertion_point(field_get:UltimateSkill.foodId)
  return foodid_;
}
inline void UltimateSkill::set_foodid(::google::protobuf::int32 value) {
  set_has_foodid();
  foodid_ = value;
  // @@protoc_insertion_point(field_set:UltimateSkill.foodId)
}

// -------------------------------------------------------------------

// PrivilegeResponse

// required int32 type = 1;
inline bool PrivilegeResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrivilegeResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrivilegeResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrivilegeResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PrivilegeResponse::type() const {
  // @@protoc_insertion_point(field_get:PrivilegeResponse.type)
  return type_;
}
inline void PrivilegeResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:PrivilegeResponse.type)
}

// optional int32 stamina = 2;
inline bool PrivilegeResponse::has_stamina() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrivilegeResponse::set_has_stamina() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrivilegeResponse::clear_has_stamina() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrivilegeResponse::clear_stamina() {
  stamina_ = 0;
  clear_has_stamina();
}
inline ::google::protobuf::int32 PrivilegeResponse::stamina() const {
  // @@protoc_insertion_point(field_get:PrivilegeResponse.stamina)
  return stamina_;
}
inline void PrivilegeResponse::set_stamina(::google::protobuf::int32 value) {
  set_has_stamina();
  stamina_ = value;
  // @@protoc_insertion_point(field_set:PrivilegeResponse.stamina)
}

// optional int32 countdown = 3;
inline bool PrivilegeResponse::has_countdown() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrivilegeResponse::set_has_countdown() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrivilegeResponse::clear_has_countdown() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrivilegeResponse::clear_countdown() {
  countdown_ = 0;
  clear_has_countdown();
}
inline ::google::protobuf::int32 PrivilegeResponse::countdown() const {
  // @@protoc_insertion_point(field_get:PrivilegeResponse.countdown)
  return countdown_;
}
inline void PrivilegeResponse::set_countdown(::google::protobuf::int32 value) {
  set_has_countdown();
  countdown_ = value;
  // @@protoc_insertion_point(field_set:PrivilegeResponse.countdown)
}

// repeated .Privilege privileges = 4;
inline int PrivilegeResponse::privileges_size() const {
  return privileges_.size();
}
inline void PrivilegeResponse::clear_privileges() {
  privileges_.Clear();
}
inline const ::Privilege& PrivilegeResponse::privileges(int index) const {
  // @@protoc_insertion_point(field_get:PrivilegeResponse.privileges)
  return privileges_.Get(index);
}
inline ::Privilege* PrivilegeResponse::mutable_privileges(int index) {
  // @@protoc_insertion_point(field_mutable:PrivilegeResponse.privileges)
  return privileges_.Mutable(index);
}
inline ::Privilege* PrivilegeResponse::add_privileges() {
  // @@protoc_insertion_point(field_add:PrivilegeResponse.privileges)
  return privileges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Privilege >&
PrivilegeResponse::privileges() const {
  // @@protoc_insertion_point(field_list:PrivilegeResponse.privileges)
  return privileges_;
}
inline ::google::protobuf::RepeatedPtrField< ::Privilege >*
PrivilegeResponse::mutable_privileges() {
  // @@protoc_insertion_point(field_mutable_list:PrivilegeResponse.privileges)
  return &privileges_;
}

// -------------------------------------------------------------------

// Privilege

// required string id = 1;
inline bool Privilege::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Privilege::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Privilege::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Privilege::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Privilege::id() const {
  // @@protoc_insertion_point(field_get:Privilege.id)
  return *id_;
}
inline void Privilege::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Privilege.id)
}
inline void Privilege::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Privilege.id)
}
inline void Privilege::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Privilege.id)
}
inline ::std::string* Privilege::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Privilege.id)
  return id_;
}
inline ::std::string* Privilege::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Privilege::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Privilege.id)
}

// required string name = 2;
inline bool Privilege::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Privilege::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Privilege::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Privilege::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Privilege::name() const {
  // @@protoc_insertion_point(field_get:Privilege.name)
  return *name_;
}
inline void Privilege::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Privilege.name)
}
inline void Privilege::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Privilege.name)
}
inline void Privilege::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Privilege.name)
}
inline ::std::string* Privilege::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Privilege.name)
  return name_;
}
inline ::std::string* Privilege::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Privilege::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Privilege.name)
}

// required int32 type = 3;
inline bool Privilege::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Privilege::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Privilege::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Privilege::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Privilege::type() const {
  // @@protoc_insertion_point(field_get:Privilege.type)
  return type_;
}
inline void Privilege::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Privilege.type)
}

// optional int32 orgPrice = 4;
inline bool Privilege::has_orgprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Privilege::set_has_orgprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Privilege::clear_has_orgprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Privilege::clear_orgprice() {
  orgprice_ = 0;
  clear_has_orgprice();
}
inline ::google::protobuf::int32 Privilege::orgprice() const {
  // @@protoc_insertion_point(field_get:Privilege.orgPrice)
  return orgprice_;
}
inline void Privilege::set_orgprice(::google::protobuf::int32 value) {
  set_has_orgprice();
  orgprice_ = value;
  // @@protoc_insertion_point(field_set:Privilege.orgPrice)
}

// required int32 price = 5;
inline bool Privilege::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Privilege::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Privilege::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Privilege::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 Privilege::price() const {
  // @@protoc_insertion_point(field_get:Privilege.price)
  return price_;
}
inline void Privilege::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:Privilege.price)
}

// optional int32 gold = 6;
inline bool Privilege::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Privilege::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Privilege::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Privilege::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 Privilege::gold() const {
  // @@protoc_insertion_point(field_get:Privilege.gold)
  return gold_;
}
inline void Privilege::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:Privilege.gold)
}

// optional int32 icon = 7;
inline bool Privilege::has_icon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Privilege::set_has_icon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Privilege::clear_has_icon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Privilege::clear_icon() {
  icon_ = 0;
  clear_has_icon();
}
inline ::google::protobuf::int32 Privilege::icon() const {
  // @@protoc_insertion_point(field_get:Privilege.icon)
  return icon_;
}
inline void Privilege::set_icon(::google::protobuf::int32 value) {
  set_has_icon();
  icon_ = value;
  // @@protoc_insertion_point(field_set:Privilege.icon)
}

// optional string poster = 8;
inline bool Privilege::has_poster() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Privilege::set_has_poster() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Privilege::clear_has_poster() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Privilege::clear_poster() {
  if (poster_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_->clear();
  }
  clear_has_poster();
}
inline const ::std::string& Privilege::poster() const {
  // @@protoc_insertion_point(field_get:Privilege.poster)
  return *poster_;
}
inline void Privilege::set_poster(const ::std::string& value) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(value);
  // @@protoc_insertion_point(field_set:Privilege.poster)
}
inline void Privilege::set_poster(const char* value) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(value);
  // @@protoc_insertion_point(field_set_char:Privilege.poster)
}
inline void Privilege::set_poster(const char* value, size_t size) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Privilege.poster)
}
inline ::std::string* Privilege::mutable_poster() {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Privilege.poster)
  return poster_;
}
inline ::std::string* Privilege::release_poster() {
  clear_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = poster_;
    poster_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Privilege::set_allocated_poster(::std::string* poster) {
  if (poster_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete poster_;
  }
  if (poster) {
    set_has_poster();
    poster_ = poster;
  } else {
    clear_has_poster();
    poster_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Privilege.poster)
}

// -------------------------------------------------------------------

// AuthorizationRequest

// required string userPayId = 1;
inline bool AuthorizationRequest::has_userpayid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthorizationRequest::set_has_userpayid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthorizationRequest::clear_has_userpayid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthorizationRequest::clear_userpayid() {
  if (userpayid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_->clear();
  }
  clear_has_userpayid();
}
inline const ::std::string& AuthorizationRequest::userpayid() const {
  // @@protoc_insertion_point(field_get:AuthorizationRequest.userPayId)
  return *userpayid_;
}
inline void AuthorizationRequest::set_userpayid(const ::std::string& value) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(value);
  // @@protoc_insertion_point(field_set:AuthorizationRequest.userPayId)
}
inline void AuthorizationRequest::set_userpayid(const char* value) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthorizationRequest.userPayId)
}
inline void AuthorizationRequest::set_userpayid(const char* value, size_t size) {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  userpayid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthorizationRequest.userPayId)
}
inline ::std::string* AuthorizationRequest::mutable_userpayid() {
  set_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userpayid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthorizationRequest.userPayId)
  return userpayid_;
}
inline ::std::string* AuthorizationRequest::release_userpayid() {
  clear_has_userpayid();
  if (userpayid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userpayid_;
    userpayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthorizationRequest::set_allocated_userpayid(::std::string* userpayid) {
  if (userpayid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userpayid_;
  }
  if (userpayid) {
    set_has_userpayid();
    userpayid_ = userpayid;
  } else {
    clear_has_userpayid();
    userpayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthorizationRequest.userPayId)
}

// -------------------------------------------------------------------

// AuthorizationResponse

// required .UserInfo userInfo = 1;
inline bool AuthorizationResponse::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthorizationResponse::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthorizationResponse::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthorizationResponse::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& AuthorizationResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:AuthorizationResponse.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* AuthorizationResponse::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:AuthorizationResponse.userInfo)
  return userinfo_;
}
inline ::UserInfo* AuthorizationResponse::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void AuthorizationResponse::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:AuthorizationResponse.userInfo)
}

// -------------------------------------------------------------------

// PayOrderRequest

// required string type = 1;
inline bool PayOrderRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOrderRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOrderRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOrderRequest::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& PayOrderRequest::type() const {
  // @@protoc_insertion_point(field_get:PayOrderRequest.type)
  return *type_;
}
inline void PayOrderRequest::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrderRequest.type)
}
inline void PayOrderRequest::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrderRequest.type)
}
inline void PayOrderRequest::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrderRequest.type)
}
inline ::std::string* PayOrderRequest::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrderRequest.type)
  return type_;
}
inline ::std::string* PayOrderRequest::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrderRequest::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrderRequest.type)
}

// required string goodsId = 2;
inline bool PayOrderRequest::has_goodsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOrderRequest::set_has_goodsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOrderRequest::clear_has_goodsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOrderRequest::clear_goodsid() {
  if (goodsid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    goodsid_->clear();
  }
  clear_has_goodsid();
}
inline const ::std::string& PayOrderRequest::goodsid() const {
  // @@protoc_insertion_point(field_get:PayOrderRequest.goodsId)
  return *goodsid_;
}
inline void PayOrderRequest::set_goodsid(const ::std::string& value) {
  set_has_goodsid();
  if (goodsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    goodsid_ = new ::std::string;
  }
  goodsid_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrderRequest.goodsId)
}
inline void PayOrderRequest::set_goodsid(const char* value) {
  set_has_goodsid();
  if (goodsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    goodsid_ = new ::std::string;
  }
  goodsid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrderRequest.goodsId)
}
inline void PayOrderRequest::set_goodsid(const char* value, size_t size) {
  set_has_goodsid();
  if (goodsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    goodsid_ = new ::std::string;
  }
  goodsid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrderRequest.goodsId)
}
inline ::std::string* PayOrderRequest::mutable_goodsid() {
  set_has_goodsid();
  if (goodsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    goodsid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrderRequest.goodsId)
  return goodsid_;
}
inline ::std::string* PayOrderRequest::release_goodsid() {
  clear_has_goodsid();
  if (goodsid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = goodsid_;
    goodsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrderRequest::set_allocated_goodsid(::std::string* goodsid) {
  if (goodsid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete goodsid_;
  }
  if (goodsid) {
    set_has_goodsid();
    goodsid_ = goodsid;
  } else {
    clear_has_goodsid();
    goodsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrderRequest.goodsId)
}

// -------------------------------------------------------------------

// PayOrderResponse

// required string orderId = 1;
inline bool PayOrderResponse::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOrderResponse::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOrderResponse::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOrderResponse::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& PayOrderResponse::orderid() const {
  // @@protoc_insertion_point(field_get:PayOrderResponse.orderId)
  return *orderid_;
}
inline void PayOrderResponse::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrderResponse.orderId)
}
inline void PayOrderResponse::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrderResponse.orderId)
}
inline void PayOrderResponse::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrderResponse.orderId)
}
inline ::std::string* PayOrderResponse::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrderResponse.orderId)
  return orderid_;
}
inline ::std::string* PayOrderResponse::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrderResponse::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrderResponse.orderId)
}

// required int32 price = 2;
inline bool PayOrderResponse::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOrderResponse::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOrderResponse::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOrderResponse::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PayOrderResponse::price() const {
  // @@protoc_insertion_point(field_get:PayOrderResponse.price)
  return price_;
}
inline void PayOrderResponse::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:PayOrderResponse.price)
}

// required .OrderParam orderParam = 3;
inline bool PayOrderResponse::has_orderparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOrderResponse::set_has_orderparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOrderResponse::clear_has_orderparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOrderResponse::clear_orderparam() {
  if (orderparam_ != NULL) orderparam_->::OrderParam::Clear();
  clear_has_orderparam();
}
inline const ::OrderParam& PayOrderResponse::orderparam() const {
  // @@protoc_insertion_point(field_get:PayOrderResponse.orderParam)
  return orderparam_ != NULL ? *orderparam_ : *default_instance_->orderparam_;
}
inline ::OrderParam* PayOrderResponse::mutable_orderparam() {
  set_has_orderparam();
  if (orderparam_ == NULL) orderparam_ = new ::OrderParam;
  // @@protoc_insertion_point(field_mutable:PayOrderResponse.orderParam)
  return orderparam_;
}
inline ::OrderParam* PayOrderResponse::release_orderparam() {
  clear_has_orderparam();
  ::OrderParam* temp = orderparam_;
  orderparam_ = NULL;
  return temp;
}
inline void PayOrderResponse::set_allocated_orderparam(::OrderParam* orderparam) {
  delete orderparam_;
  orderparam_ = orderparam;
  if (orderparam) {
    set_has_orderparam();
  } else {
    clear_has_orderparam();
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrderResponse.orderParam)
}

// optional int32 continueType = 4;
inline bool PayOrderResponse::has_continuetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayOrderResponse::set_has_continuetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayOrderResponse::clear_has_continuetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayOrderResponse::clear_continuetype() {
  continuetype_ = 0;
  clear_has_continuetype();
}
inline ::google::protobuf::int32 PayOrderResponse::continuetype() const {
  // @@protoc_insertion_point(field_get:PayOrderResponse.continueType)
  return continuetype_;
}
inline void PayOrderResponse::set_continuetype(::google::protobuf::int32 value) {
  set_has_continuetype();
  continuetype_ = value;
  // @@protoc_insertion_point(field_set:PayOrderResponse.continueType)
}

// -------------------------------------------------------------------

// OrderParam

// optional string name = 1;
inline bool OrderParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderParam::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OrderParam::name() const {
  // @@protoc_insertion_point(field_get:OrderParam.name)
  return *name_;
}
inline void OrderParam::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:OrderParam.name)
}
inline void OrderParam::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderParam.name)
}
inline void OrderParam::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderParam.name)
}
inline ::std::string* OrderParam::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderParam.name)
  return name_;
}
inline ::std::string* OrderParam::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderParam::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderParam.name)
}

// optional string unicomFeeId = 2;
inline bool OrderParam::has_unicomfeeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderParam::set_has_unicomfeeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderParam::clear_has_unicomfeeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderParam::clear_unicomfeeid() {
  if (unicomfeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomfeeid_->clear();
  }
  clear_has_unicomfeeid();
}
inline const ::std::string& OrderParam::unicomfeeid() const {
  // @@protoc_insertion_point(field_get:OrderParam.unicomFeeId)
  return *unicomfeeid_;
}
inline void OrderParam::set_unicomfeeid(const ::std::string& value) {
  set_has_unicomfeeid();
  if (unicomfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomfeeid_ = new ::std::string;
  }
  unicomfeeid_->assign(value);
  // @@protoc_insertion_point(field_set:OrderParam.unicomFeeId)
}
inline void OrderParam::set_unicomfeeid(const char* value) {
  set_has_unicomfeeid();
  if (unicomfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomfeeid_ = new ::std::string;
  }
  unicomfeeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderParam.unicomFeeId)
}
inline void OrderParam::set_unicomfeeid(const char* value, size_t size) {
  set_has_unicomfeeid();
  if (unicomfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomfeeid_ = new ::std::string;
  }
  unicomfeeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderParam.unicomFeeId)
}
inline ::std::string* OrderParam::mutable_unicomfeeid() {
  set_has_unicomfeeid();
  if (unicomfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomfeeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderParam.unicomFeeId)
  return unicomfeeid_;
}
inline ::std::string* OrderParam::release_unicomfeeid() {
  clear_has_unicomfeeid();
  if (unicomfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unicomfeeid_;
    unicomfeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderParam::set_allocated_unicomfeeid(::std::string* unicomfeeid) {
  if (unicomfeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unicomfeeid_;
  }
  if (unicomfeeid) {
    set_has_unicomfeeid();
    unicomfeeid_ = unicomfeeid;
  } else {
    clear_has_unicomfeeid();
    unicomfeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderParam.unicomFeeId)
}

// optional string unicomProductId = 3;
inline bool OrderParam::has_unicomproductid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderParam::set_has_unicomproductid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderParam::clear_has_unicomproductid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderParam::clear_unicomproductid() {
  if (unicomproductid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomproductid_->clear();
  }
  clear_has_unicomproductid();
}
inline const ::std::string& OrderParam::unicomproductid() const {
  // @@protoc_insertion_point(field_get:OrderParam.unicomProductId)
  return *unicomproductid_;
}
inline void OrderParam::set_unicomproductid(const ::std::string& value) {
  set_has_unicomproductid();
  if (unicomproductid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomproductid_ = new ::std::string;
  }
  unicomproductid_->assign(value);
  // @@protoc_insertion_point(field_set:OrderParam.unicomProductId)
}
inline void OrderParam::set_unicomproductid(const char* value) {
  set_has_unicomproductid();
  if (unicomproductid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomproductid_ = new ::std::string;
  }
  unicomproductid_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderParam.unicomProductId)
}
inline void OrderParam::set_unicomproductid(const char* value, size_t size) {
  set_has_unicomproductid();
  if (unicomproductid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomproductid_ = new ::std::string;
  }
  unicomproductid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderParam.unicomProductId)
}
inline ::std::string* OrderParam::mutable_unicomproductid() {
  set_has_unicomproductid();
  if (unicomproductid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unicomproductid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderParam.unicomProductId)
  return unicomproductid_;
}
inline ::std::string* OrderParam::release_unicomproductid() {
  clear_has_unicomproductid();
  if (unicomproductid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unicomproductid_;
    unicomproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderParam::set_allocated_unicomproductid(::std::string* unicomproductid) {
  if (unicomproductid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unicomproductid_;
  }
  if (unicomproductid) {
    set_has_unicomproductid();
    unicomproductid_ = unicomproductid;
  } else {
    clear_has_unicomproductid();
    unicomproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderParam.unicomProductId)
}

// optional string aliFeeId = 4;
inline bool OrderParam::has_alifeeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderParam::set_has_alifeeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderParam::clear_has_alifeeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderParam::clear_alifeeid() {
  if (alifeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alifeeid_->clear();
  }
  clear_has_alifeeid();
}
inline const ::std::string& OrderParam::alifeeid() const {
  // @@protoc_insertion_point(field_get:OrderParam.aliFeeId)
  return *alifeeid_;
}
inline void OrderParam::set_alifeeid(const ::std::string& value) {
  set_has_alifeeid();
  if (alifeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alifeeid_ = new ::std::string;
  }
  alifeeid_->assign(value);
  // @@protoc_insertion_point(field_set:OrderParam.aliFeeId)
}
inline void OrderParam::set_alifeeid(const char* value) {
  set_has_alifeeid();
  if (alifeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alifeeid_ = new ::std::string;
  }
  alifeeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderParam.aliFeeId)
}
inline void OrderParam::set_alifeeid(const char* value, size_t size) {
  set_has_alifeeid();
  if (alifeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alifeeid_ = new ::std::string;
  }
  alifeeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderParam.aliFeeId)
}
inline ::std::string* OrderParam::mutable_alifeeid() {
  set_has_alifeeid();
  if (alifeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alifeeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderParam.aliFeeId)
  return alifeeid_;
}
inline ::std::string* OrderParam::release_alifeeid() {
  clear_has_alifeeid();
  if (alifeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alifeeid_;
    alifeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderParam::set_allocated_alifeeid(::std::string* alifeeid) {
  if (alifeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alifeeid_;
  }
  if (alifeeid) {
    set_has_alifeeid();
    alifeeid_ = alifeeid;
  } else {
    clear_has_alifeeid();
    alifeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderParam.aliFeeId)
}

// optional string weixinFeeId = 5;
inline bool OrderParam::has_weixinfeeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderParam::set_has_weixinfeeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderParam::clear_has_weixinfeeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderParam::clear_weixinfeeid() {
  if (weixinfeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinfeeid_->clear();
  }
  clear_has_weixinfeeid();
}
inline const ::std::string& OrderParam::weixinfeeid() const {
  // @@protoc_insertion_point(field_get:OrderParam.weixinFeeId)
  return *weixinfeeid_;
}
inline void OrderParam::set_weixinfeeid(const ::std::string& value) {
  set_has_weixinfeeid();
  if (weixinfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinfeeid_ = new ::std::string;
  }
  weixinfeeid_->assign(value);
  // @@protoc_insertion_point(field_set:OrderParam.weixinFeeId)
}
inline void OrderParam::set_weixinfeeid(const char* value) {
  set_has_weixinfeeid();
  if (weixinfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinfeeid_ = new ::std::string;
  }
  weixinfeeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderParam.weixinFeeId)
}
inline void OrderParam::set_weixinfeeid(const char* value, size_t size) {
  set_has_weixinfeeid();
  if (weixinfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinfeeid_ = new ::std::string;
  }
  weixinfeeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderParam.weixinFeeId)
}
inline ::std::string* OrderParam::mutable_weixinfeeid() {
  set_has_weixinfeeid();
  if (weixinfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinfeeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderParam.weixinFeeId)
  return weixinfeeid_;
}
inline ::std::string* OrderParam::release_weixinfeeid() {
  clear_has_weixinfeeid();
  if (weixinfeeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = weixinfeeid_;
    weixinfeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderParam::set_allocated_weixinfeeid(::std::string* weixinfeeid) {
  if (weixinfeeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete weixinfeeid_;
  }
  if (weixinfeeid) {
    set_has_weixinfeeid();
    weixinfeeid_ = weixinfeeid;
  } else {
    clear_has_weixinfeeid();
    weixinfeeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderParam.weixinFeeId)
}

// optional bool notify = 6;
inline bool OrderParam::has_notify() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderParam::set_has_notify() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderParam::clear_has_notify() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderParam::clear_notify() {
  notify_ = false;
  clear_has_notify();
}
inline bool OrderParam::notify() const {
  // @@protoc_insertion_point(field_get:OrderParam.notify)
  return notify_;
}
inline void OrderParam::set_notify(bool value) {
  set_has_notify();
  notify_ = value;
  // @@protoc_insertion_point(field_set:OrderParam.notify)
}

// -------------------------------------------------------------------

// PayResultRequest

// required string type = 1;
inline bool PayResultRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayResultRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayResultRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayResultRequest::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& PayResultRequest::type() const {
  // @@protoc_insertion_point(field_get:PayResultRequest.type)
  return *type_;
}
inline void PayResultRequest::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:PayResultRequest.type)
}
inline void PayResultRequest::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayResultRequest.type)
}
inline void PayResultRequest::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayResultRequest.type)
}
inline ::std::string* PayResultRequest::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayResultRequest.type)
  return type_;
}
inline ::std::string* PayResultRequest::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayResultRequest::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultRequest.type)
}

// required string orderId = 2;
inline bool PayResultRequest::has_orderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayResultRequest::set_has_orderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayResultRequest::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayResultRequest::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& PayResultRequest::orderid() const {
  // @@protoc_insertion_point(field_get:PayResultRequest.orderId)
  return *orderid_;
}
inline void PayResultRequest::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set:PayResultRequest.orderId)
}
inline void PayResultRequest::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayResultRequest.orderId)
}
inline void PayResultRequest::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayResultRequest.orderId)
}
inline ::std::string* PayResultRequest::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayResultRequest.orderId)
  return orderid_;
}
inline ::std::string* PayResultRequest::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayResultRequest::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultRequest.orderId)
}

// required string orderStatus = 3;
inline bool PayResultRequest::has_orderstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayResultRequest::set_has_orderstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayResultRequest::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayResultRequest::clear_orderstatus() {
  if (orderstatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_->clear();
  }
  clear_has_orderstatus();
}
inline const ::std::string& PayResultRequest::orderstatus() const {
  // @@protoc_insertion_point(field_get:PayResultRequest.orderStatus)
  return *orderstatus_;
}
inline void PayResultRequest::set_orderstatus(const ::std::string& value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
  // @@protoc_insertion_point(field_set:PayResultRequest.orderStatus)
}
inline void PayResultRequest::set_orderstatus(const char* value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayResultRequest.orderStatus)
}
inline void PayResultRequest::set_orderstatus(const char* value, size_t size) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayResultRequest.orderStatus)
}
inline ::std::string* PayResultRequest::mutable_orderstatus() {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayResultRequest.orderStatus)
  return orderstatus_;
}
inline ::std::string* PayResultRequest::release_orderstatus() {
  clear_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderstatus_;
    orderstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayResultRequest::set_allocated_orderstatus(::std::string* orderstatus) {
  if (orderstatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderstatus_;
  }
  if (orderstatus) {
    set_has_orderstatus();
    orderstatus_ = orderstatus;
  } else {
    clear_has_orderstatus();
    orderstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultRequest.orderStatus)
}

// -------------------------------------------------------------------

// PayResultResponse

// required string orderId = 1;
inline bool PayResultResponse::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayResultResponse::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayResultResponse::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayResultResponse::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& PayResultResponse::orderid() const {
  // @@protoc_insertion_point(field_get:PayResultResponse.orderId)
  return *orderid_;
}
inline void PayResultResponse::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set:PayResultResponse.orderId)
}
inline void PayResultResponse::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayResultResponse.orderId)
}
inline void PayResultResponse::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayResultResponse.orderId)
}
inline ::std::string* PayResultResponse::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayResultResponse.orderId)
  return orderid_;
}
inline ::std::string* PayResultResponse::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayResultResponse::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultResponse.orderId)
}

// required string orderStatus = 2;
inline bool PayResultResponse::has_orderstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayResultResponse::set_has_orderstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayResultResponse::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayResultResponse::clear_orderstatus() {
  if (orderstatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_->clear();
  }
  clear_has_orderstatus();
}
inline const ::std::string& PayResultResponse::orderstatus() const {
  // @@protoc_insertion_point(field_get:PayResultResponse.orderStatus)
  return *orderstatus_;
}
inline void PayResultResponse::set_orderstatus(const ::std::string& value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
  // @@protoc_insertion_point(field_set:PayResultResponse.orderStatus)
}
inline void PayResultResponse::set_orderstatus(const char* value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayResultResponse.orderStatus)
}
inline void PayResultResponse::set_orderstatus(const char* value, size_t size) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayResultResponse.orderStatus)
}
inline ::std::string* PayResultResponse::mutable_orderstatus() {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderstatus_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayResultResponse.orderStatus)
  return orderstatus_;
}
inline ::std::string* PayResultResponse::release_orderstatus() {
  clear_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderstatus_;
    orderstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayResultResponse::set_allocated_orderstatus(::std::string* orderstatus) {
  if (orderstatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderstatus_;
  }
  if (orderstatus) {
    set_has_orderstatus();
    orderstatus_ = orderstatus;
  } else {
    clear_has_orderstatus();
    orderstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultResponse.orderStatus)
}

// optional .UserInfo userInfo = 3;
inline bool PayResultResponse::has_userinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayResultResponse::set_has_userinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayResultResponse::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayResultResponse::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& PayResultResponse::userinfo() const {
  // @@protoc_insertion_point(field_get:PayResultResponse.userInfo)
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* PayResultResponse::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  // @@protoc_insertion_point(field_mutable:PayResultResponse.userInfo)
  return userinfo_;
}
inline ::UserInfo* PayResultResponse::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void PayResultResponse::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:PayResultResponse.userInfo)
}

// -------------------------------------------------------------------

// GoldCoinListRequest

// required int32 page = 1;
inline bool GoldCoinListRequest::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoldCoinListRequest::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoldCoinListRequest::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoldCoinListRequest::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 GoldCoinListRequest::page() const {
  // @@protoc_insertion_point(field_get:GoldCoinListRequest.page)
  return page_;
}
inline void GoldCoinListRequest::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:GoldCoinListRequest.page)
}

// required int32 limit = 2;
inline bool GoldCoinListRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoldCoinListRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoldCoinListRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoldCoinListRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 GoldCoinListRequest::limit() const {
  // @@protoc_insertion_point(field_get:GoldCoinListRequest.limit)
  return limit_;
}
inline void GoldCoinListRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:GoldCoinListRequest.limit)
}

// -------------------------------------------------------------------

// GoldCoinListResponse

// repeated .GoldCoin goldCoin = 1;
inline int GoldCoinListResponse::goldcoin_size() const {
  return goldcoin_.size();
}
inline void GoldCoinListResponse::clear_goldcoin() {
  goldcoin_.Clear();
}
inline const ::GoldCoin& GoldCoinListResponse::goldcoin(int index) const {
  // @@protoc_insertion_point(field_get:GoldCoinListResponse.goldCoin)
  return goldcoin_.Get(index);
}
inline ::GoldCoin* GoldCoinListResponse::mutable_goldcoin(int index) {
  // @@protoc_insertion_point(field_mutable:GoldCoinListResponse.goldCoin)
  return goldcoin_.Mutable(index);
}
inline ::GoldCoin* GoldCoinListResponse::add_goldcoin() {
  // @@protoc_insertion_point(field_add:GoldCoinListResponse.goldCoin)
  return goldcoin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GoldCoin >&
GoldCoinListResponse::goldcoin() const {
  // @@protoc_insertion_point(field_list:GoldCoinListResponse.goldCoin)
  return goldcoin_;
}
inline ::google::protobuf::RepeatedPtrField< ::GoldCoin >*
GoldCoinListResponse::mutable_goldcoin() {
  // @@protoc_insertion_point(field_mutable_list:GoldCoinListResponse.goldCoin)
  return &goldcoin_;
}

// -------------------------------------------------------------------

// GoldCoin

// required string id = 1;
inline bool GoldCoin::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoldCoin::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoldCoin::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoldCoin::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GoldCoin::id() const {
  // @@protoc_insertion_point(field_get:GoldCoin.id)
  return *id_;
}
inline void GoldCoin::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:GoldCoin.id)
}
inline void GoldCoin::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoldCoin.id)
}
inline void GoldCoin::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoldCoin.id)
}
inline ::std::string* GoldCoin::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoldCoin.id)
  return id_;
}
inline ::std::string* GoldCoin::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoldCoin::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoldCoin.id)
}

// required bool canBuy = 2;
inline bool GoldCoin::has_canbuy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoldCoin::set_has_canbuy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoldCoin::clear_has_canbuy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoldCoin::clear_canbuy() {
  canbuy_ = false;
  clear_has_canbuy();
}
inline bool GoldCoin::canbuy() const {
  // @@protoc_insertion_point(field_get:GoldCoin.canBuy)
  return canbuy_;
}
inline void GoldCoin::set_canbuy(bool value) {
  set_has_canbuy();
  canbuy_ = value;
  // @@protoc_insertion_point(field_set:GoldCoin.canBuy)
}

// optional int32 gold = 3;
inline bool GoldCoin::has_gold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoldCoin::set_has_gold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoldCoin::clear_has_gold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoldCoin::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 GoldCoin::gold() const {
  // @@protoc_insertion_point(field_get:GoldCoin.gold)
  return gold_;
}
inline void GoldCoin::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:GoldCoin.gold)
}

// optional int32 price = 4;
inline bool GoldCoin::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GoldCoin::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GoldCoin::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GoldCoin::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 GoldCoin::price() const {
  // @@protoc_insertion_point(field_get:GoldCoin.price)
  return price_;
}
inline void GoldCoin::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:GoldCoin.price)
}

// optional string poster = 6;
inline bool GoldCoin::has_poster() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GoldCoin::set_has_poster() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GoldCoin::clear_has_poster() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GoldCoin::clear_poster() {
  if (poster_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_->clear();
  }
  clear_has_poster();
}
inline const ::std::string& GoldCoin::poster() const {
  // @@protoc_insertion_point(field_get:GoldCoin.poster)
  return *poster_;
}
inline void GoldCoin::set_poster(const ::std::string& value) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(value);
  // @@protoc_insertion_point(field_set:GoldCoin.poster)
}
inline void GoldCoin::set_poster(const char* value) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoldCoin.poster)
}
inline void GoldCoin::set_poster(const char* value, size_t size) {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  poster_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoldCoin.poster)
}
inline ::std::string* GoldCoin::mutable_poster() {
  set_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    poster_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoldCoin.poster)
  return poster_;
}
inline ::std::string* GoldCoin::release_poster() {
  clear_has_poster();
  if (poster_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = poster_;
    poster_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoldCoin::set_allocated_poster(::std::string* poster) {
  if (poster_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete poster_;
  }
  if (poster) {
    set_has_poster();
    poster_ = poster;
  } else {
    clear_has_poster();
    poster_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoldCoin.poster)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_2eproto__INCLUDED
